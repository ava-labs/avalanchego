// Copyright (C) 2019, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package warp

import (
	"github.com/ava-labs/avalanchego/ids"
	"github.com/stretchr/testify/require"
	"testing"
)

// TODO rename
// TestCodecSerialization ensures the serialization format remains stable.
func TestCodecSerialization(t *testing.T) {
	tests := []struct {
		name      string
		msg       *ValidatorUptime
		wantBytes []byte
	}{
		{
			name: "zero values",
			msg: &ValidatorUptime{},
			wantBytes: []byte{
				// Codec version (0)
				0x00, 0x00,
				// ValidationID (32 bytes of zeros)
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				// TotalUptime (8 bytes, uint64 = 0)
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		},
		{
			name: "non-zero values",
			msg: &ValidatorUptime{
				ValidationID: ids.ID{
					0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
					0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
					0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
					0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
				},
				TotalUptimeSeconds: 12345,
			},
			wantBytes: []byte{
				// Codec version (0)
				0x00, 0x00,
				// ValidationID (32 bytes)
				0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
				0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
				0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
				0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
				// TotalUptime (8 bytes, uint64 = 12345 in big-endian)
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x39,
			},
		},
		{
			name: "max uptime",
			msg: &ValidatorUptime{
				ValidationID: ids.ID{
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				TotalUptimeSeconds: ^uint64(0),
			},
			wantBytes: []byte{
				// Codec version (0)
				0x00, 0x00,
				// ValidationID (32 bytes of 0xff)
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				// TotalUptime (8 bytes, max uint64 in big-endian)
				0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotBytes, err := tt.msg.Bytes()
			require.NoError(t, err)
			require.Equal(t, tt.wantBytes, gotBytes)

			// TODO separate test?
			gotMsg, err := ParseValidatorUptime(tt.wantBytes)
			require.NoError(t, err)
			require.Equal(t, tt.msg.ValidationID, gotMsg.ValidationID)
			require.Equal(t, tt.msg.TotalUptimeSeconds, gotMsg.TotalUptimeSeconds)
		})
	}
}
