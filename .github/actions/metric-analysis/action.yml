name: Metric Correlation Analysis
description: Correlate metrics across multiple jobs/runs for performance comparison

inputs:
  queries:
    description: |
      Array of query objects for correlation analysis.

      Each query object must have:
      - query (required, string): Prometheus query expression
      - metric_name (required, string): Display name for the metric
      - y_axis_label (optional, string): Y-axis label for the chart

      Example:
        queries:
          - query: "rate(http_requests_total[5m])"
            metric_name: "HTTP Request Rate"
            y_axis_label: "Requests/sec"
          - query: "avg(cpu_usage_percent)"
            metric_name: "CPU Usage"
            y_axis_label: "Percentage"
    required: true
  dashboard_title:
    description: 'Title for the correlation dashboard'
    default: 'Metric Correlation Analysis'
  x_axis_label:
    description: 'X-axis label'
    default: 'Time'
  prometheus_url:
    description: 'Prometheus server URL'
    default: 'https://prometheus-poc.avax-dev.network'
  prometheus_username:
    required: true
  prometheus_password:
    required: true
  step_size:
    description: 'Prometheus query step size'
    default: '15s'
  timezone:
    description: 'Display timezone'
    default: 'US/Eastern'
  github_token:
    description: 'GitHub token'
    default: ${{ github.token }}

runs:
  using: composite
  steps:
    - name: Build correlation configuration
      id: build-config
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const fs = require('fs');
          const path = require('path');

          // Get job names from the needs context
          const JOB_NAMES = Object.keys(context.needs || {});
          if (JOB_NAMES.length === 0) {
            throw new Error('No jobs found in needs context. Make sure this job has a needs: [] declaration.');
          }

          const CURRENT_RUN_ID = context.runId.toString();
          const ACTION_PATH = process.env.GITHUB_ACTION_PATH;

          console.log(`Correlating jobs from needs: ${JOB_NAMES.join(', ')}`);

          // Parse and validate queries input
          let queries;
          try {
            const queriesInput = `${{ inputs.queries }}`;
            queries = JSON.parse(queriesInput);

            // Strong validation
            if (!Array.isArray(queries)) {
              throw new Error('queries must be an array');
            }

            if (queries.length === 0) {
              throw new Error('queries array cannot be empty');
            }

            // Validate each query object
            queries.forEach((query, index) => {
              if (typeof query !== 'object' || query === null) {
                throw new Error(`Query ${index}: must be an object`);
              }

              // Required fields
              if (!query.query || typeof query.query !== 'string') {
                throw new Error(`Query ${index}: 'query' field is required and must be a string`);
              }

              if (!query.metric_name || typeof query.metric_name !== 'string') {
                throw new Error(`Query ${index}: 'metric_name' field is required and must be a string`);
              }

              // Optional fields validation
              if (query.y_axis_label && typeof query.y_axis_label !== 'string') {
                throw new Error(`Query ${index}: 'y_axis_label' must be a string if provided`);
              }

              // Check for unknown fields
              const allowedFields = ['query', 'metric_name', 'y_axis_label'];
              const providedFields = Object.keys(query);
              const unknownFields = providedFields.filter(field => !allowedFields.includes(field));

              if (unknownFields.length > 0) {
                console.log(`Query ${index}: Unknown fields detected: ${unknownFields.join(', ')}. Allowed fields: ${allowedFields.join(', ')}`);
              }
            });

            console.log(`âœ“ Validated ${queries.length} queries successfully`);

          } catch (error) {
            console.error('Queries validation failed:', error.message);
            throw new Error(`Invalid queries format: ${error.message}`);
          }

          // Get precise job timings from GitHub Jobs API
          console.log('Fetching job timings from GitHub API...');
          const { data: workflowJobs } = await github.rest.actions.listJobsForWorkflowRun({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: CURRENT_RUN_ID
          });

          const correlationRuns = [];

          // Process each job from needs context
          for (const jobName of JOB_NAMES) {
            const jobData = workflowJobs.jobs.find(job => job.name === jobName);

            if (jobData && jobData.started_at && jobData.completed_at) {
              correlationRuns.push({
                job_name: jobName,
                name: jobName,
                labels: {
                  gh_run_id: CURRENT_RUN_ID,
                  gh_job_id: jobName,
                  gh_run_attempt: "1",
                  gh_repo: context.repo.owner + "/" + context.repo.repo,
                  is_ephemeral_node: "false"
                },
                start_time: new Date(jobData.started_at).getTime(),
                end_time: new Date(jobData.completed_at).getTime()
              });

              console.log(`Added job: ${jobName} (${jobData.started_at} to ${jobData.completed_at})`);
            } else {
              console.log(`Warning: Could not find timing data for job ${jobName}`);
            }
          }

          if (correlationRuns.length === 0) {
            throw new Error(`No valid job timing found for any jobs in needs: [${JOB_NAMES.join(', ')}]`);
          }

          // Create output file path
          const outputFile = `correlation_analysis_${CURRENT_RUN_ID}.html`;
          const outputPath = path.join(ACTION_PATH, outputFile);

          // Build configuration for multi_plot.py
          const config = {
            queries: queries,
            dashboard_title: '${{ inputs.dashboard_title }}',
            x_axis_label: '${{ inputs.x_axis_label }}',
            correlation_runs: correlationRuns,
            output_file: outputPath
          };

          const configPath = path.join(ACTION_PATH, 'correlation_config.json');
          fs.writeFileSync(configPath, JSON.stringify(config, null, 2));

          console.log(`Correlation config written to: ${configPath}`);
          console.log(`Total jobs for correlation: ${correlationRuns.length}`);

          core.setOutput('config_path', configPath);
          core.setOutput('output_file', outputPath);
          core.setOutput('jobs_correlated', JOB_NAMES.join(','));
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
    - name: Install Python dependencies
      shell: bash
      run: pip install -r $GITHUB_ACTION_PATH/requirements.txt
    - name: Run correlation analysis
      shell: bash
      env:
        PROMETHEUS_ID: ${{ inputs.prometheus_username }}
        PROMETHEUS_PASSWORD: ${{ inputs.prometheus_password }}
      run: |
        python $GITHUB_ACTION_PATH/multi_plot.py \
          --config ${{ steps.build-config.outputs.config_path }} \
          --prometheus-url "${{ inputs.prometheus_url }}" \
          --step-size "${{ inputs.step_size }}" \
          --timezone "${{ inputs.timezone }}" \
          --verbose
    - name: Upload correlation artifact
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: metric-correlation-${{ github.run_id }}
        path: |
          ${{ steps.build-config.outputs.output_file }}
          ${{ steps.build-config.outputs.config_path }}
        retention-days: 14
    - name: Log correlation summary
      shell: bash
      run: |
        echo "::notice::Correlation analysis completed for jobs: ${{ steps.build-config.outputs.jobs_correlated }}"
        echo "::notice::Visualization available in artifact: metric-correlation-${{ github.run_id }}"
