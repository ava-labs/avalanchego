name: analysis
author: elvis.sabanovic
description: analysis

inputs:
  baseline_count:
    description: 'Number of baseline runs to find'
    default: '3'
  monitoring_period:
    description: 'Monitoring period in seconds'
    default: '900'
  query:
    description: 'Prometheus query'
    required: true
  metric_name:
    description: 'Metric name for display'
    required: true
  x_axis_label:
    description: 'X-axis label'
    default: 'Time'
  y_axis_label:
    description: 'Y-axis label'
    default: ''
  workflow_file:
    description: 'Workflow file name (e.g., c-chain-reexecution-benchmark.yml)'
    default: ''
  job_name:
    description: 'Job name to search for baselines'
    default: ''

runs:
  using: composite
  steps:
    - name: Generate baseline configuration
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Configuration
          const BASELINE_COUNT = parseInt('${{ inputs.baseline_count }}');
          const MONITORING_PERIOD = parseInt('${{ inputs.monitoring_period }}');
          const CURRENT_RUN_ID = '${{ github.run_id }}';
          const CURRENT_RUN_ATTEMPT = '${{ github.run_attempt }}';
          const JOB_ID = '${{ inputs.job_name }}' || '${{ github.job }}';
          const WORKFLOW_FILE = '${{ inputs.workflow_file }}';
          const REPO = '${{ github.repository }}';

          console.log(`DEBUG: Looking for ${BASELINE_COUNT} baselines`);
          console.log(`DEBUG: Workflow file: '${WORKFLOW_FILE}'`);
          console.log(`DEBUG: Job name: '${JOB_ID}'`);
          console.log(`DEBUG: Current run ID: ${CURRENT_RUN_ID}`);

          // Get workflow runs by workflow file name
          const { data: { workflow_runs } } = await github.rest.actions.listWorkflowRuns({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: WORKFLOW_FILE,
            status: 'completed',
            per_page: 20
          });

          console.log(`DEBUG: Found ${workflow_runs.length} runs for workflow file '${WORKFLOW_FILE}'`);

          // Show successful runs
          const successfulRuns = workflow_runs.filter(run => run.conclusion === 'success');
          console.log(`DEBUG: Found ${successfulRuns.length} successful runs`);

          // Show the first few runs for debugging
          successfulRuns.slice(0, 5).forEach(run => {
            console.log(`DEBUG: Run ${run.run_number} (ID: ${run.id}) - ${run.conclusion}`);
          });

          const baselineRuns = [];

          for (const run of successfulRuns) {
            if (baselineRuns.length >= BASELINE_COUNT) {
              break;
            }

            // Exclude current run
            if (run.id.toString() === CURRENT_RUN_ID) {
              console.log(`DEBUG: Skipping current run ${run.id}`);
              continue;
            }

            console.log(`DEBUG: Checking jobs for run ${run.id} (run #${run.run_number})`);

            try {
              const { data: { jobs } } = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: run.id
              });

              console.log(`DEBUG: Found ${jobs.length} jobs in run ${run.id}`);
              jobs.forEach(job => {
                console.log(`DEBUG: Job: '${job.name}' - ${job.conclusion}`);
              });

              // Find matching job
              const targetJob = jobs.find(job => job.name === JOB_ID && job.conclusion === 'success');

              if (targetJob) {
                console.log(`DEBUG: Found matching job '${targetJob.name}' in run ${run.id}`);
                baselineRuns.push({
                  run_id: run.id.toString(),
                  run_number: run.run_number
                });
              } else {
                console.log(`DEBUG: No matching job '${JOB_ID}' found in run ${run.id}`);
              }
            } catch (error) {
              console.log(`DEBUG: Failed to get jobs for run ${run.id}: ${error.message}`);
            }
          }

          console.log(`DEBUG: Found ${baselineRuns.length} baseline runs`);

          // Calculate current run timing
          const currentStart = Date.now();
          const currentEnd = currentStart + (MONITORING_PERIOD * 1000);

          // Build configuration
          const config = {
            query: '${{ inputs.query }}',
            metric_name: '${{ inputs.metric_name }}',
            x_axis_label: '${{ inputs.x_axis_label }}',
            y_axis_label: '${{ inputs.y_axis_label }}' || '${{ inputs.metric_name }}',
            candidate: {
              start_time: currentStart,
              end_time: currentEnd,
              name: `Current Run (#${CURRENT_RUN_ID})`,
              labels: {
                gh_run_id: CURRENT_RUN_ID,
                gh_job_id: JOB_ID,
                gh_run_attempt: CURRENT_RUN_ATTEMPT,
                gh_repo: REPO
              }
            },
            baselines: baselineRuns.map(run => ({
              name: `Run ${run.run_number} (#${run.run_id})`,
              labels: {
                gh_run_id: run.run_id,
                gh_job_id: JOB_ID,
                gh_run_attempt: "1",
                gh_repo: REPO
              }
            })),
            output_file: `metric_visualization_${CURRENT_RUN_ID}.html`
          };

          // Write configuration file
          fs.writeFileSync('metric_config.json', JSON.stringify(config, null, 2));
          console.log('Configuration file created: metric_config.json');

    - name: Show generated config
      shell: bash
      run: |
        if [ -f metric_config.json ]; then
          echo "Generated configuration:"
          cat metric_config.json
        else
          echo "ERROR: metric_config.json not found"
          exit 1
        fi
