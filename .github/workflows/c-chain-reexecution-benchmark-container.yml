name: C-Chain Re-Execution Benchmark w/ Container

on:
  pull_request:
  workflow_dispatch:
    inputs:
      test:
        description: 'Test name (e.g., hashdb-101-250k, firewood-33m-33m500k). Leave empty for custom.'
        default: ''
      config:
        description: 'The config to pass to the VM for the benchmark. See BenchmarkReexecuteRange for details.'
        default: ''
      start-block:
        description: 'The start block for the benchmark.'
        default: ''
      end-block:
        description: 'The end block for the benchmark.'
        default: ''
      block-dir-src:
        description: 'The source block directory. Supports S3 directory/zip and local directories.'
        default: ''
      current-state-dir-src:
        description: 'The current state directory. Supports S3 directory/zip and local directories.'
        default: ''
      runner:
        description: 'Runner to execute the benchmark. Input to the runs-on field of the job.'
        required: true
      push-post-state:
        description: 'S3 location to push post-execution state directory. Skips this step if left unpopulated.'
        default: ''
      timeout-minutes:
        description: 'Timeout in minutes for the job.'
        default: 30
      with-dependencies:
        description: 'Dependencies to use (e.g., "firewood=abc123" or "firewood=abc,libevm=xyz")'
        default: ''

  # Disabled because scheduled trigger is empty. To enable, uncomment and add at least one vector to the schedule
  # entry in the corresponding JSON file.
  schedule:
    - cron: '0 9 * * *' # Runs every day at 09:00 UTC (04:00 EST)

jobs:
  define-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.define-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - name: Define Matrix
        id: define-matrix
        shell: bash -x {0}
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            FIREWOOD_REF="" LIBEVM_REF=""
            [[ "${{ github.event.inputs.with-dependencies }}" =~ firewood=([^,]+) ]] && FIREWOOD_REF="${BASH_REMATCH[1]}"
            [[ "${{ github.event.inputs.with-dependencies }}" =~ libevm=([^,]+) ]] && LIBEVM_REF="${BASH_REMATCH[1]}"
            {
              echo "matrix<<EOF"
              printf '{ "include": [{ "test": "%s", "start-block": "%s", "end-block": "%s", "block-dir-src": "%s", "current-state-dir-src": "%s", "config": "%s", "runner": "%s", "timeout-minutes": %s, "firewood-ref": "%s", "libevm-ref": "%s" }] }\n' \
                "${{ github.event.inputs.test }}" \
                "${{ github.event.inputs.start-block }}" \
                "${{ github.event.inputs.end-block }}" \
                "${{ github.event.inputs.block-dir-src }}" \
                "${{ github.event.inputs.current-state-dir-src }}" \
                "${{ github.event.inputs.config }}" \
                "${{ github.event.inputs.runner }}" \
                "${{ github.event.inputs.timeout-minutes }}" \
                "$FIREWOOD_REF" \
                "$LIBEVM_REF"
              echo EOF
            } >> "$GITHUB_OUTPUT"
          else
            json_string=$(jq -r ".\"${{ github.event_name }}\"" .github/workflows/c-chain-reexecution-benchmark-container.json)
            {
              echo "matrix<<EOF"
              echo "$json_string"
              echo EOF
            } >> "$GITHUB_OUTPUT"
          fi

  c-chain-reexecution:
    needs: define-matrix
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.define-matrix.outputs.matrix) }}
    timeout-minutes: ${{ matrix.timeout-minutes }}
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == 'ava-labs/avalanchego' }}
    permissions:
      id-token: write
      contents: write
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
      - name: Verify shell error handling
        run: |
          set -euo pipefail
          echo "==> Shell options:"
          set -o | grep -E "errexit|pipefail|nounset"

          echo ""
          echo "==> TEST 1: set -e catches direct command failure"
          echo "Running: /bin/false (should exit immediately)"
          set +e
          (
            set -euo pipefail
            /bin/false
            echo "ERROR: This should NOT print - set -e failed to catch /bin/false"
          )
          test1_exit=$?
          set -e
          if [[ $test1_exit -ne 0 ]]; then
            echo "PASS: Subshell exited with code $test1_exit (set -e caught /bin/false)"
          else
            echo "FAIL: Subshell exited with code 0"
          fi

          echo ""
          echo "==> TEST 2: set -e does NOT catch failure inside \$(command substitution)"
          echo "Running: output=\$(/bin/false) - does set -e catch this?"
          set +e
          (
            set -euo pipefail
            output=$(/bin/false)
            echo "Script continued after \$(/bin/false) - exit code was: $?"
            echo "This proves set -e does NOT catch errors in command substitution!"
          )
          test2_exit=$?
          set -e
          echo "Subshell exit code: $test2_exit"

          echo ""
          echo "==> TEST 3: Explicit || pattern catches command substitution failure"
          echo "Running: output=\$(/bin/false) || exit 1"
          set +e
          (
            set -euo pipefail
            output=$(/bin/false) || { echo "Caught failure with ||"; exit 1; }
            echo "ERROR: This should NOT print"
          )
          test3_exit=$?
          set -e
          if [[ $test3_exit -ne 0 ]]; then
            echo "PASS: Explicit || caught the failure (exit code $test3_exit)"
          else
            echo "FAIL: || did not catch failure"
          fi

          echo ""
          echo "==> TEST 4: gh workflow run with command substitution (simulating original bug)"
          if ! command -v gh &> /dev/null; then
            echo "gh CLI not installed - installing..."
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt-get update
            sudo apt-get install gh -y
          fi
          echo "gh version: $(gh --version | head -1)"

          echo ""
          echo "Running: output=\$(gh workflow run non-existent-workflow.yml 2>&1)"
          set +e
          (
            set -euo pipefail
            output=$(gh workflow run non-existent-workflow.yml 2>&1)
            echo "Script continued after gh failure!"
            echo "Output was: $output"
            echo "This is why the original bug occurred - set -e doesn't catch \$() failures"
          )
          test4_exit=$?
          set -e
          echo "Subshell exit code: $test4_exit"

          echo ""
          echo "==> SUMMARY"
          echo "- set -e catches direct command failures: YES"
          echo "- set -e catches \$(command) failures: NO"
          echo "- Explicit || or 'if !' catches \$(command) failures: YES"
          echo ""
          echo "CONCLUSION: Always use explicit error handling for commands in \$() substitution:"
          echo '  output=$(command) || { echo "error"; exit 1; }'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Install ARC Dependencies
        shell: bash
        run: |
          # xz-utils might be present on some containers. Install if not present.
          if ! command -v xz &> /dev/null; then
            sudo apt-get update
            sudo apt-get install -y xz-utils
          fi
      # Nix is required before calling polyrepo
      # c-chain-reexecution-benchmark's Nix install will be skipped; installation is idempotent.
      - name: Install Nix
        if: matrix.libevm-ref != '' || matrix.firewood-ref != ''
        uses: cachix/install-nix-action@02a151ada4993995686f9ed4f1be7cfbb229e56f #v31
        with:
          github_access_token: ${{ secrets.GITHUB_TOKEN }}
      - name: Configure dependency versions
        if: matrix.libevm-ref != '' || matrix.firewood-ref != ''
        shell: nix develop --command bash {0}
        run: ./scripts/run_task.sh run-polyrepo
        env:
          LIBEVM_REF: ${{ matrix.libevm-ref }}
          FIREWOOD_REF: ${{ matrix.firewood-ref }}
          # Required for Nix builds on ARC runners
          TMPDIR: /tmp
          NIX_BUILD_TOP: /tmp
      - name: Run C-Chain Re-Execution Benchmark
        uses: ./.github/actions/c-chain-reexecution-benchmark
        with:
          test: ${{ matrix.test }}
          config: ${{ matrix.config }}
          start-block: ${{ matrix.start-block }}
          end-block: ${{ matrix.end-block }}
          block-dir-src: ${{ matrix.block-dir-src }}
          current-state-dir-src: ${{ matrix.current-state-dir-src }}
          prometheus-url: ${{ secrets.PROMETHEUS_URL || '' }}
          prometheus-push-url: ${{ secrets.PROMETHEUS_PUSH_URL || '' }}
          prometheus-username: ${{ secrets.PROMETHEUS_USERNAME || '' }}
          prometheus-password: ${{ secrets.PROMETHEUS_PASSWORD || '' }}
          push-github-action-benchmark: ${{ (github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.repository == 'ava-labs/avalanchego' && github.ref_name == 'master')) && matrix.firewood-ref == '' }}
          skip-benchmark-comparison: ${{ matrix.firewood-ref != '' || matrix.libevm-ref != '' }}
          aws-role: ${{ github.event.inputs.push-post-state != '' && secrets.AWS_S3_RW_ROLE || secrets.AWS_S3_READ_ONLY_ROLE }}
          aws-region: 'us-east-2'
          github-token: ${{ secrets.GITHUB_TOKEN }}
          push-post-state: ${{ github.event.inputs.push-post-state }}
          runner_type: ${{ matrix.runner }}
