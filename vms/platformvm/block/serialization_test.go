// Copyright (C) 2019-2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package block

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/ava-labs/avalanchego/vms/platformvm/txs"
)

func TestBanffBlockSerialization(t *testing.T) {
	type test struct {
		block BanffBlock
		bytes []byte
	}

	tests := []test{
		{
			block: &BanffProposalBlock{
				ApricotProposalBlock: ApricotProposalBlock{
					Tx: &txs.Tx{
						Unsigned: &txs.AdvanceTimeTx{},
					},
				},
			},
			bytes: []byte{
				// Codec version
				0x00, 0x00,
				// Type ID
				0x00, 0x00, 0x00, 0x1d,
				// Rest
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
		},
		{
			block: &BanffCommitBlock{
				ApricotCommitBlock: ApricotCommitBlock{},
			},
			bytes: []byte{
				// Codec version
				0x00, 0x00,
				// Type ID
				0x00, 0x00, 0x00, 0x1f,
				// Rest
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		},
		{
			block: &BanffAbortBlock{
				ApricotAbortBlock: ApricotAbortBlock{},
			},
			bytes: []byte{
				// Codec version
				0x00, 0x00,
				// Type ID
				0x00, 0x00, 0x00, 0x1e,
				// Rest
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			},
		},
		{
			block: &BanffStandardBlock{
				ApricotStandardBlock: ApricotStandardBlock{
					Transactions: []*txs.Tx{},
				},
			},
			bytes: []byte{
				// Codec version
				0x00, 0x00,
				// Type ID
				0x00, 0x00, 0x00, 0x20,
				// Rest
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00,
			},
		},
	}

	for _, test := range tests {
		testName := fmt.Sprintf("%T", test.block)
		t.Run(testName, func(t *testing.T) {
			require := require.New(t)

			require.NoError(initialize(test.block))
			require.Equal(test.bytes, test.block.Bytes())
		})
	}
}
