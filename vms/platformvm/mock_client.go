// Copyright (C) 2019-2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/ava-labs/avalanchego/vms/platformvm (interfaces: Client)

// Package platformvm is a generated GoMock package.
package platformvm

import (
	context "context"
	reflect "reflect"
	time "time"

	api "github.com/ava-labs/avalanchego/api"
	ids "github.com/ava-labs/avalanchego/ids"
	secp256k1 "github.com/ava-labs/avalanchego/utils/crypto/secp256k1"
	rpc "github.com/ava-labs/avalanchego/utils/rpc"
	status "github.com/ava-labs/avalanchego/vms/platformvm/status"
	gomock "github.com/golang/mock/gomock"
)

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// AddDelegator mocks base method.
func (m *MockClient) AddDelegator(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3, arg4 ids.ShortID, arg5 ids.NodeID, arg6, arg7, arg8 uint64, arg9 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}
	for _, a := range arg9 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddDelegator", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddDelegator indicates an expected call of AddDelegator.
func (mr *MockClientMockRecorder) AddDelegator(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 interface{}, arg9 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}, arg9...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddDelegator", reflect.TypeOf((*MockClient)(nil).AddDelegator), varargs...)
}

// AddSubnetValidator mocks base method.
func (m *MockClient) AddSubnetValidator(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3 ids.ShortID, arg4 ids.ID, arg5 ids.NodeID, arg6, arg7, arg8 uint64, arg9 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}
	for _, a := range arg9 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddSubnetValidator", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddSubnetValidator indicates an expected call of AddSubnetValidator.
func (mr *MockClientMockRecorder) AddSubnetValidator(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 interface{}, arg9 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}, arg9...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSubnetValidator", reflect.TypeOf((*MockClient)(nil).AddSubnetValidator), varargs...)
}

// AddValidator mocks base method.
func (m *MockClient) AddValidator(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3, arg4 ids.ShortID, arg5 ids.NodeID, arg6, arg7, arg8 uint64, arg9 float32, arg10 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9}
	for _, a := range arg10 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddValidator", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddValidator indicates an expected call of AddValidator.
func (mr *MockClientMockRecorder) AddValidator(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 interface{}, arg10 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9}, arg10...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddValidator", reflect.TypeOf((*MockClient)(nil).AddValidator), varargs...)
}

// AwaitTxDecided mocks base method.
func (m *MockClient) AwaitTxDecided(arg0 context.Context, arg1 ids.ID, arg2 time.Duration, arg3 ...rpc.Option) (*GetTxStatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AwaitTxDecided", varargs...)
	ret0, _ := ret[0].(*GetTxStatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AwaitTxDecided indicates an expected call of AwaitTxDecided.
func (mr *MockClientMockRecorder) AwaitTxDecided(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AwaitTxDecided", reflect.TypeOf((*MockClient)(nil).AwaitTxDecided), varargs...)
}

// CreateAddress mocks base method.
func (m *MockClient) CreateAddress(arg0 context.Context, arg1 api.UserPass, arg2 ...rpc.Option) (ids.ShortID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAddress", varargs...)
	ret0, _ := ret[0].(ids.ShortID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAddress indicates an expected call of CreateAddress.
func (mr *MockClientMockRecorder) CreateAddress(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAddress", reflect.TypeOf((*MockClient)(nil).CreateAddress), varargs...)
}

// CreateBlockchain mocks base method.
func (m *MockClient) CreateBlockchain(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3 ids.ShortID, arg4 ids.ID, arg5 string, arg6 []string, arg7 string, arg8 []byte, arg9 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}
	for _, a := range arg9 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateBlockchain", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateBlockchain indicates an expected call of CreateBlockchain.
func (mr *MockClientMockRecorder) CreateBlockchain(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 interface{}, arg9 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8}, arg9...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateBlockchain", reflect.TypeOf((*MockClient)(nil).CreateBlockchain), varargs...)
}

// CreateSubnet mocks base method.
func (m *MockClient) CreateSubnet(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3 ids.ShortID, arg4 []ids.ShortID, arg5 uint32, arg6 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5}
	for _, a := range arg6 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateSubnet", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateSubnet indicates an expected call of CreateSubnet.
func (mr *MockClientMockRecorder) CreateSubnet(arg0, arg1, arg2, arg3, arg4, arg5 interface{}, arg6 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5}, arg6...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSubnet", reflect.TypeOf((*MockClient)(nil).CreateSubnet), varargs...)
}

// ExportAVAX mocks base method.
func (m *MockClient) ExportAVAX(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3, arg4 ids.ShortID, arg5 string, arg6 uint64, arg7 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6}
	for _, a := range arg7 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExportAVAX", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExportAVAX indicates an expected call of ExportAVAX.
func (mr *MockClientMockRecorder) ExportAVAX(arg0, arg1, arg2, arg3, arg4, arg5, arg6 interface{}, arg7 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5, arg6}, arg7...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportAVAX", reflect.TypeOf((*MockClient)(nil).ExportAVAX), varargs...)
}

// ExportKey mocks base method.
func (m *MockClient) ExportKey(arg0 context.Context, arg1 api.UserPass, arg2 ids.ShortID, arg3 ...rpc.Option) (*secp256k1.PrivateKey, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExportKey", varargs...)
	ret0, _ := ret[0].(*secp256k1.PrivateKey)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExportKey indicates an expected call of ExportKey.
func (mr *MockClientMockRecorder) ExportKey(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportKey", reflect.TypeOf((*MockClient)(nil).ExportKey), varargs...)
}

// GetAtomicUTXOs mocks base method.
func (m *MockClient) GetAtomicUTXOs(arg0 context.Context, arg1 []ids.ShortID, arg2 string, arg3 uint32, arg4 ids.ShortID, arg5 ids.ID, arg6 ...rpc.Option) ([][]byte, ids.ShortID, ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5}
	for _, a := range arg6 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetAtomicUTXOs", varargs...)
	ret0, _ := ret[0].([][]byte)
	ret1, _ := ret[1].(ids.ShortID)
	ret2, _ := ret[2].(ids.ID)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetAtomicUTXOs indicates an expected call of GetAtomicUTXOs.
func (mr *MockClientMockRecorder) GetAtomicUTXOs(arg0, arg1, arg2, arg3, arg4, arg5 interface{}, arg6 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5}, arg6...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAtomicUTXOs", reflect.TypeOf((*MockClient)(nil).GetAtomicUTXOs), varargs...)
}

// GetBalance mocks base method.
func (m *MockClient) GetBalance(arg0 context.Context, arg1 []ids.ShortID, arg2 ...rpc.Option) (*GetBalanceResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBalance", varargs...)
	ret0, _ := ret[0].(*GetBalanceResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalance indicates an expected call of GetBalance.
func (mr *MockClientMockRecorder) GetBalance(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalance", reflect.TypeOf((*MockClient)(nil).GetBalance), varargs...)
}

// GetBlock mocks base method.
func (m *MockClient) GetBlock(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) ([]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlock", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlock indicates an expected call of GetBlock.
func (mr *MockClientMockRecorder) GetBlock(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlock", reflect.TypeOf((*MockClient)(nil).GetBlock), varargs...)
}

// GetBlockchainStatus mocks base method.
func (m *MockClient) GetBlockchainStatus(arg0 context.Context, arg1 string, arg2 ...rpc.Option) (status.BlockchainStatus, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlockchainStatus", varargs...)
	ret0, _ := ret[0].(status.BlockchainStatus)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockchainStatus indicates an expected call of GetBlockchainStatus.
func (mr *MockClientMockRecorder) GetBlockchainStatus(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockchainStatus", reflect.TypeOf((*MockClient)(nil).GetBlockchainStatus), varargs...)
}

// GetBlockchains mocks base method.
func (m *MockClient) GetBlockchains(arg0 context.Context, arg1 ...rpc.Option) ([]APIBlockchain, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetBlockchains", varargs...)
	ret0, _ := ret[0].([]APIBlockchain)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBlockchains indicates an expected call of GetBlockchains.
func (mr *MockClientMockRecorder) GetBlockchains(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockchains", reflect.TypeOf((*MockClient)(nil).GetBlockchains), varargs...)
}

// GetCurrentSupply mocks base method.
func (m *MockClient) GetCurrentSupply(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCurrentSupply", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentSupply indicates an expected call of GetCurrentSupply.
func (mr *MockClientMockRecorder) GetCurrentSupply(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentSupply", reflect.TypeOf((*MockClient)(nil).GetCurrentSupply), varargs...)
}

// GetCurrentValidators mocks base method.
func (m *MockClient) GetCurrentValidators(arg0 context.Context, arg1 ids.ID, arg2 []ids.NodeID, arg3 ...rpc.Option) ([]ClientPermissionlessValidator, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetCurrentValidators", varargs...)
	ret0, _ := ret[0].([]ClientPermissionlessValidator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetCurrentValidators indicates an expected call of GetCurrentValidators.
func (mr *MockClientMockRecorder) GetCurrentValidators(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentValidators", reflect.TypeOf((*MockClient)(nil).GetCurrentValidators), varargs...)
}

// GetHeight mocks base method.
func (m *MockClient) GetHeight(arg0 context.Context, arg1 ...rpc.Option) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetHeight", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetHeight indicates an expected call of GetHeight.
func (mr *MockClientMockRecorder) GetHeight(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetHeight", reflect.TypeOf((*MockClient)(nil).GetHeight), varargs...)
}

// GetMaxStakeAmount mocks base method.
func (m *MockClient) GetMaxStakeAmount(arg0 context.Context, arg1 ids.ID, arg2 ids.NodeID, arg3, arg4 uint64, arg5 ...rpc.Option) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMaxStakeAmount", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMaxStakeAmount indicates an expected call of GetMaxStakeAmount.
func (mr *MockClientMockRecorder) GetMaxStakeAmount(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMaxStakeAmount", reflect.TypeOf((*MockClient)(nil).GetMaxStakeAmount), varargs...)
}

// GetMinStake mocks base method.
func (m *MockClient) GetMinStake(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMinStake", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetMinStake indicates an expected call of GetMinStake.
func (mr *MockClientMockRecorder) GetMinStake(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMinStake", reflect.TypeOf((*MockClient)(nil).GetMinStake), varargs...)
}

// GetPendingValidators mocks base method.
func (m *MockClient) GetPendingValidators(arg0 context.Context, arg1 ids.ID, arg2 []ids.NodeID, arg3 ...rpc.Option) ([]interface{}, []interface{}, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPendingValidators", varargs...)
	ret0, _ := ret[0].([]interface{})
	ret1, _ := ret[1].([]interface{})
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetPendingValidators indicates an expected call of GetPendingValidators.
func (mr *MockClientMockRecorder) GetPendingValidators(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingValidators", reflect.TypeOf((*MockClient)(nil).GetPendingValidators), varargs...)
}

// GetRewardUTXOs mocks base method.
func (m *MockClient) GetRewardUTXOs(arg0 context.Context, arg1 *api.GetTxArgs, arg2 ...rpc.Option) ([][]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetRewardUTXOs", varargs...)
	ret0, _ := ret[0].([][]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRewardUTXOs indicates an expected call of GetRewardUTXOs.
func (mr *MockClientMockRecorder) GetRewardUTXOs(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRewardUTXOs", reflect.TypeOf((*MockClient)(nil).GetRewardUTXOs), varargs...)
}

// GetStake mocks base method.
func (m *MockClient) GetStake(arg0 context.Context, arg1 []ids.ShortID, arg2 bool, arg3 ...rpc.Option) (map[ids.ID]uint64, [][]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetStake", varargs...)
	ret0, _ := ret[0].(map[ids.ID]uint64)
	ret1, _ := ret[1].([][]byte)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetStake indicates an expected call of GetStake.
func (mr *MockClientMockRecorder) GetStake(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStake", reflect.TypeOf((*MockClient)(nil).GetStake), varargs...)
}

// GetStakingAssetID mocks base method.
func (m *MockClient) GetStakingAssetID(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetStakingAssetID", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStakingAssetID indicates an expected call of GetStakingAssetID.
func (mr *MockClientMockRecorder) GetStakingAssetID(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStakingAssetID", reflect.TypeOf((*MockClient)(nil).GetStakingAssetID), varargs...)
}

// GetSubnets mocks base method.
func (m *MockClient) GetSubnets(arg0 context.Context, arg1 []ids.ID, arg2 ...rpc.Option) ([]ClientSubnet, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetSubnets", varargs...)
	ret0, _ := ret[0].([]ClientSubnet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSubnets indicates an expected call of GetSubnets.
func (mr *MockClientMockRecorder) GetSubnets(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSubnets", reflect.TypeOf((*MockClient)(nil).GetSubnets), varargs...)
}

// GetTimestamp mocks base method.
func (m *MockClient) GetTimestamp(arg0 context.Context, arg1 ...rpc.Option) (time.Time, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTimestamp", varargs...)
	ret0, _ := ret[0].(time.Time)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTimestamp indicates an expected call of GetTimestamp.
func (mr *MockClientMockRecorder) GetTimestamp(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTimestamp", reflect.TypeOf((*MockClient)(nil).GetTimestamp), varargs...)
}

// GetTotalStake mocks base method.
func (m *MockClient) GetTotalStake(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTotalStake", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTotalStake indicates an expected call of GetTotalStake.
func (mr *MockClientMockRecorder) GetTotalStake(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalStake", reflect.TypeOf((*MockClient)(nil).GetTotalStake), varargs...)
}

// GetTx mocks base method.
func (m *MockClient) GetTx(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) ([]byte, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTx", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTx indicates an expected call of GetTx.
func (mr *MockClientMockRecorder) GetTx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTx", reflect.TypeOf((*MockClient)(nil).GetTx), varargs...)
}

// GetTxStatus mocks base method.
func (m *MockClient) GetTxStatus(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (*GetTxStatusResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetTxStatus", varargs...)
	ret0, _ := ret[0].(*GetTxStatusResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTxStatus indicates an expected call of GetTxStatus.
func (mr *MockClientMockRecorder) GetTxStatus(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTxStatus", reflect.TypeOf((*MockClient)(nil).GetTxStatus), varargs...)
}

// GetUTXOs mocks base method.
func (m *MockClient) GetUTXOs(arg0 context.Context, arg1 []ids.ShortID, arg2 uint32, arg3 ids.ShortID, arg4 ids.ID, arg5 ...rpc.Option) ([][]byte, ids.ShortID, ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUTXOs", varargs...)
	ret0, _ := ret[0].([][]byte)
	ret1, _ := ret[1].(ids.ShortID)
	ret2, _ := ret[2].(ids.ID)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetUTXOs indicates an expected call of GetUTXOs.
func (mr *MockClientMockRecorder) GetUTXOs(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUTXOs", reflect.TypeOf((*MockClient)(nil).GetUTXOs), varargs...)
}

// GetValidatorsAt mocks base method.
func (m *MockClient) GetValidatorsAt(arg0 context.Context, arg1 ids.ID, arg2 uint64, arg3 ...rpc.Option) (map[ids.NodeID]uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetValidatorsAt", varargs...)
	ret0, _ := ret[0].(map[ids.NodeID]uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetValidatorsAt indicates an expected call of GetValidatorsAt.
func (mr *MockClientMockRecorder) GetValidatorsAt(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetValidatorsAt", reflect.TypeOf((*MockClient)(nil).GetValidatorsAt), varargs...)
}

// ImportAVAX mocks base method.
func (m *MockClient) ImportAVAX(arg0 context.Context, arg1 api.UserPass, arg2 []ids.ShortID, arg3, arg4 ids.ShortID, arg5 string, arg6 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5}
	for _, a := range arg6 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ImportAVAX", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ImportAVAX indicates an expected call of ImportAVAX.
func (mr *MockClientMockRecorder) ImportAVAX(arg0, arg1, arg2, arg3, arg4, arg5 interface{}, arg6 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5}, arg6...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImportAVAX", reflect.TypeOf((*MockClient)(nil).ImportAVAX), varargs...)
}

// ImportKey mocks base method.
func (m *MockClient) ImportKey(arg0 context.Context, arg1 api.UserPass, arg2 *secp256k1.PrivateKey, arg3 ...rpc.Option) (ids.ShortID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ImportKey", varargs...)
	ret0, _ := ret[0].(ids.ShortID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ImportKey indicates an expected call of ImportKey.
func (mr *MockClientMockRecorder) ImportKey(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImportKey", reflect.TypeOf((*MockClient)(nil).ImportKey), varargs...)
}

// IssueTx mocks base method.
func (m *MockClient) IssueTx(arg0 context.Context, arg1 []byte, arg2 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "IssueTx", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IssueTx indicates an expected call of IssueTx.
func (mr *MockClientMockRecorder) IssueTx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IssueTx", reflect.TypeOf((*MockClient)(nil).IssueTx), varargs...)
}

// ListAddresses mocks base method.
func (m *MockClient) ListAddresses(arg0 context.Context, arg1 api.UserPass, arg2 ...rpc.Option) ([]ids.ShortID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAddresses", varargs...)
	ret0, _ := ret[0].([]ids.ShortID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAddresses indicates an expected call of ListAddresses.
func (mr *MockClientMockRecorder) ListAddresses(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAddresses", reflect.TypeOf((*MockClient)(nil).ListAddresses), varargs...)
}

// SampleValidators mocks base method.
func (m *MockClient) SampleValidators(arg0 context.Context, arg1 ids.ID, arg2 uint16, arg3 ...rpc.Option) ([]ids.NodeID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SampleValidators", varargs...)
	ret0, _ := ret[0].([]ids.NodeID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SampleValidators indicates an expected call of SampleValidators.
func (mr *MockClientMockRecorder) SampleValidators(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SampleValidators", reflect.TypeOf((*MockClient)(nil).SampleValidators), varargs...)
}

// ValidatedBy mocks base method.
func (m *MockClient) ValidatedBy(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) (ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ValidatedBy", varargs...)
	ret0, _ := ret[0].(ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidatedBy indicates an expected call of ValidatedBy.
func (mr *MockClientMockRecorder) ValidatedBy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidatedBy", reflect.TypeOf((*MockClient)(nil).ValidatedBy), varargs...)
}

// Validates mocks base method.
func (m *MockClient) Validates(arg0 context.Context, arg1 ids.ID, arg2 ...rpc.Option) ([]ids.ID, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Validates", varargs...)
	ret0, _ := ret[0].([]ids.ID)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Validates indicates an expected call of Validates.
func (mr *MockClientMockRecorder) Validates(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validates", reflect.TypeOf((*MockClient)(nil).Validates), varargs...)
}
