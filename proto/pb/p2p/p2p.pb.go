// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: p2p/p2p.proto

package p2p

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The consensus engine that should be used when handling a consensus request.
type EngineType int32

const (
	EngineType_ENGINE_TYPE_UNSPECIFIED EngineType = 0
	// Only the X-Chain uses DAG consensus
	EngineType_ENGINE_TYPE_DAG   EngineType = 1
	EngineType_ENGINE_TYPE_CHAIN EngineType = 2
)

// Enum value maps for EngineType.
var (
	EngineType_name = map[int32]string{
		0: "ENGINE_TYPE_UNSPECIFIED",
		1: "ENGINE_TYPE_DAG",
		2: "ENGINE_TYPE_CHAIN",
	}
	EngineType_value = map[string]int32{
		"ENGINE_TYPE_UNSPECIFIED": 0,
		"ENGINE_TYPE_DAG":         1,
		"ENGINE_TYPE_CHAIN":       2,
	}
)

func (x EngineType) Enum() *EngineType {
	p := new(EngineType)
	*p = x
	return p
}

func (x EngineType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EngineType) Descriptor() protoreflect.EnumDescriptor {
	return file_p2p_p2p_proto_enumTypes[0].Descriptor()
}

func (EngineType) Type() protoreflect.EnumType {
	return &file_p2p_p2p_proto_enumTypes[0]
}

func (x EngineType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EngineType.Descriptor instead.
func (EngineType) EnumDescriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{0}
}

// Represents peer-to-peer messages.
// Only one type can be non-null.
type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NOTES
	// Use "oneof" for each message type and set rest to null if not used.
	// That is because when the compression is enabled, we don't want to include uncompressed fields.
	//
	// Types that are valid to be assigned to Message:
	//
	//	*Message_CompressedZstd
	//	*Message_Ping
	//	*Message_Pong
	//	*Message_Handshake
	//	*Message_GetPeerList
	//	*Message_PeerList_
	//	*Message_GetStateSummaryFrontier
	//	*Message_StateSummaryFrontier_
	//	*Message_GetAcceptedStateSummary
	//	*Message_AcceptedStateSummary_
	//	*Message_GetAcceptedFrontier
	//	*Message_AcceptedFrontier_
	//	*Message_GetAccepted
	//	*Message_Accepted_
	//	*Message_GetAncestors
	//	*Message_Ancestors_
	//	*Message_Get
	//	*Message_Put
	//	*Message_PushQuery
	//	*Message_PullQuery
	//	*Message_Chits
	//	*Message_AppRequest
	//	*Message_AppResponse
	//	*Message_AppGossip
	//	*Message_AppError
	//	*Message_Simplex
	Message       isMessage_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_p2p_p2p_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{0}
}

func (x *Message) GetMessage() isMessage_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *Message) GetCompressedZstd() []byte {
	if x != nil {
		if x, ok := x.Message.(*Message_CompressedZstd); ok {
			return x.CompressedZstd
		}
	}
	return nil
}

func (x *Message) GetPing() *Ping {
	if x != nil {
		if x, ok := x.Message.(*Message_Ping); ok {
			return x.Ping
		}
	}
	return nil
}

func (x *Message) GetPong() *Pong {
	if x != nil {
		if x, ok := x.Message.(*Message_Pong); ok {
			return x.Pong
		}
	}
	return nil
}

func (x *Message) GetHandshake() *Handshake {
	if x != nil {
		if x, ok := x.Message.(*Message_Handshake); ok {
			return x.Handshake
		}
	}
	return nil
}

func (x *Message) GetGetPeerList() *GetPeerList {
	if x != nil {
		if x, ok := x.Message.(*Message_GetPeerList); ok {
			return x.GetPeerList
		}
	}
	return nil
}

func (x *Message) GetPeerList_() *PeerList {
	if x != nil {
		if x, ok := x.Message.(*Message_PeerList_); ok {
			return x.PeerList_
		}
	}
	return nil
}

func (x *Message) GetGetStateSummaryFrontier() *GetStateSummaryFrontier {
	if x != nil {
		if x, ok := x.Message.(*Message_GetStateSummaryFrontier); ok {
			return x.GetStateSummaryFrontier
		}
	}
	return nil
}

func (x *Message) GetStateSummaryFrontier_() *StateSummaryFrontier {
	if x != nil {
		if x, ok := x.Message.(*Message_StateSummaryFrontier_); ok {
			return x.StateSummaryFrontier_
		}
	}
	return nil
}

func (x *Message) GetGetAcceptedStateSummary() *GetAcceptedStateSummary {
	if x != nil {
		if x, ok := x.Message.(*Message_GetAcceptedStateSummary); ok {
			return x.GetAcceptedStateSummary
		}
	}
	return nil
}

func (x *Message) GetAcceptedStateSummary_() *AcceptedStateSummary {
	if x != nil {
		if x, ok := x.Message.(*Message_AcceptedStateSummary_); ok {
			return x.AcceptedStateSummary_
		}
	}
	return nil
}

func (x *Message) GetGetAcceptedFrontier() *GetAcceptedFrontier {
	if x != nil {
		if x, ok := x.Message.(*Message_GetAcceptedFrontier); ok {
			return x.GetAcceptedFrontier
		}
	}
	return nil
}

func (x *Message) GetAcceptedFrontier_() *AcceptedFrontier {
	if x != nil {
		if x, ok := x.Message.(*Message_AcceptedFrontier_); ok {
			return x.AcceptedFrontier_
		}
	}
	return nil
}

func (x *Message) GetGetAccepted() *GetAccepted {
	if x != nil {
		if x, ok := x.Message.(*Message_GetAccepted); ok {
			return x.GetAccepted
		}
	}
	return nil
}

func (x *Message) GetAccepted_() *Accepted {
	if x != nil {
		if x, ok := x.Message.(*Message_Accepted_); ok {
			return x.Accepted_
		}
	}
	return nil
}

func (x *Message) GetGetAncestors() *GetAncestors {
	if x != nil {
		if x, ok := x.Message.(*Message_GetAncestors); ok {
			return x.GetAncestors
		}
	}
	return nil
}

func (x *Message) GetAncestors_() *Ancestors {
	if x != nil {
		if x, ok := x.Message.(*Message_Ancestors_); ok {
			return x.Ancestors_
		}
	}
	return nil
}

func (x *Message) GetGet() *Get {
	if x != nil {
		if x, ok := x.Message.(*Message_Get); ok {
			return x.Get
		}
	}
	return nil
}

func (x *Message) GetPut() *Put {
	if x != nil {
		if x, ok := x.Message.(*Message_Put); ok {
			return x.Put
		}
	}
	return nil
}

func (x *Message) GetPushQuery() *PushQuery {
	if x != nil {
		if x, ok := x.Message.(*Message_PushQuery); ok {
			return x.PushQuery
		}
	}
	return nil
}

func (x *Message) GetPullQuery() *PullQuery {
	if x != nil {
		if x, ok := x.Message.(*Message_PullQuery); ok {
			return x.PullQuery
		}
	}
	return nil
}

func (x *Message) GetChits() *Chits {
	if x != nil {
		if x, ok := x.Message.(*Message_Chits); ok {
			return x.Chits
		}
	}
	return nil
}

func (x *Message) GetAppRequest() *AppRequest {
	if x != nil {
		if x, ok := x.Message.(*Message_AppRequest); ok {
			return x.AppRequest
		}
	}
	return nil
}

func (x *Message) GetAppResponse() *AppResponse {
	if x != nil {
		if x, ok := x.Message.(*Message_AppResponse); ok {
			return x.AppResponse
		}
	}
	return nil
}

func (x *Message) GetAppGossip() *AppGossip {
	if x != nil {
		if x, ok := x.Message.(*Message_AppGossip); ok {
			return x.AppGossip
		}
	}
	return nil
}

func (x *Message) GetAppError() *AppError {
	if x != nil {
		if x, ok := x.Message.(*Message_AppError); ok {
			return x.AppError
		}
	}
	return nil
}

func (x *Message) GetSimplex() *Simplex {
	if x != nil {
		if x, ok := x.Message.(*Message_Simplex); ok {
			return x.Simplex
		}
	}
	return nil
}

type isMessage_Message interface {
	isMessage_Message()
}

type Message_CompressedZstd struct {
	// zstd-compressed bytes of a "p2p.Message" whose "oneof" "message" field is
	// NOT compressed_* BUT one of the message types (e.g. ping, pong, etc.).
	// This field is only set if the message type supports compression.
	CompressedZstd []byte `protobuf:"bytes,2,opt,name=compressed_zstd,json=compressedZstd,proto3,oneof"`
}

type Message_Ping struct {
	// Network messages:
	Ping *Ping `protobuf:"bytes,11,opt,name=ping,proto3,oneof"`
}

type Message_Pong struct {
	Pong *Pong `protobuf:"bytes,12,opt,name=pong,proto3,oneof"`
}

type Message_Handshake struct {
	Handshake *Handshake `protobuf:"bytes,13,opt,name=handshake,proto3,oneof"`
}

type Message_GetPeerList struct {
	GetPeerList *GetPeerList `protobuf:"bytes,35,opt,name=get_peer_list,json=getPeerList,proto3,oneof"`
}

type Message_PeerList_ struct {
	PeerList_ *PeerList `protobuf:"bytes,14,opt,name=peer_list,json=peerList,proto3,oneof"`
}

type Message_GetStateSummaryFrontier struct {
	// State-sync messages:
	GetStateSummaryFrontier *GetStateSummaryFrontier `protobuf:"bytes,15,opt,name=get_state_summary_frontier,json=getStateSummaryFrontier,proto3,oneof"`
}

type Message_StateSummaryFrontier_ struct {
	StateSummaryFrontier_ *StateSummaryFrontier `protobuf:"bytes,16,opt,name=state_summary_frontier,json=stateSummaryFrontier,proto3,oneof"`
}

type Message_GetAcceptedStateSummary struct {
	GetAcceptedStateSummary *GetAcceptedStateSummary `protobuf:"bytes,17,opt,name=get_accepted_state_summary,json=getAcceptedStateSummary,proto3,oneof"`
}

type Message_AcceptedStateSummary_ struct {
	AcceptedStateSummary_ *AcceptedStateSummary `protobuf:"bytes,18,opt,name=accepted_state_summary,json=acceptedStateSummary,proto3,oneof"`
}

type Message_GetAcceptedFrontier struct {
	// Bootstrapping messages:
	GetAcceptedFrontier *GetAcceptedFrontier `protobuf:"bytes,19,opt,name=get_accepted_frontier,json=getAcceptedFrontier,proto3,oneof"`
}

type Message_AcceptedFrontier_ struct {
	AcceptedFrontier_ *AcceptedFrontier `protobuf:"bytes,20,opt,name=accepted_frontier,json=acceptedFrontier,proto3,oneof"`
}

type Message_GetAccepted struct {
	GetAccepted *GetAccepted `protobuf:"bytes,21,opt,name=get_accepted,json=getAccepted,proto3,oneof"`
}

type Message_Accepted_ struct {
	Accepted_ *Accepted `protobuf:"bytes,22,opt,name=accepted,proto3,oneof"`
}

type Message_GetAncestors struct {
	GetAncestors *GetAncestors `protobuf:"bytes,23,opt,name=get_ancestors,json=getAncestors,proto3,oneof"`
}

type Message_Ancestors_ struct {
	Ancestors_ *Ancestors `protobuf:"bytes,24,opt,name=ancestors,proto3,oneof"`
}

type Message_Get struct {
	// Consensus messages:
	Get *Get `protobuf:"bytes,25,opt,name=get,proto3,oneof"`
}

type Message_Put struct {
	Put *Put `protobuf:"bytes,26,opt,name=put,proto3,oneof"`
}

type Message_PushQuery struct {
	PushQuery *PushQuery `protobuf:"bytes,27,opt,name=push_query,json=pushQuery,proto3,oneof"`
}

type Message_PullQuery struct {
	PullQuery *PullQuery `protobuf:"bytes,28,opt,name=pull_query,json=pullQuery,proto3,oneof"`
}

type Message_Chits struct {
	Chits *Chits `protobuf:"bytes,29,opt,name=chits,proto3,oneof"`
}

type Message_AppRequest struct {
	// App messages:
	AppRequest *AppRequest `protobuf:"bytes,30,opt,name=app_request,json=appRequest,proto3,oneof"`
}

type Message_AppResponse struct {
	AppResponse *AppResponse `protobuf:"bytes,31,opt,name=app_response,json=appResponse,proto3,oneof"`
}

type Message_AppGossip struct {
	AppGossip *AppGossip `protobuf:"bytes,32,opt,name=app_gossip,json=appGossip,proto3,oneof"`
}

type Message_AppError struct {
	AppError *AppError `protobuf:"bytes,34,opt,name=app_error,json=appError,proto3,oneof"`
}

type Message_Simplex struct {
	// Simplex messages:
	Simplex *Simplex `protobuf:"bytes,36,opt,name=simplex,proto3,oneof"`
}

func (*Message_CompressedZstd) isMessage_Message() {}

func (*Message_Ping) isMessage_Message() {}

func (*Message_Pong) isMessage_Message() {}

func (*Message_Handshake) isMessage_Message() {}

func (*Message_GetPeerList) isMessage_Message() {}

func (*Message_PeerList_) isMessage_Message() {}

func (*Message_GetStateSummaryFrontier) isMessage_Message() {}

func (*Message_StateSummaryFrontier_) isMessage_Message() {}

func (*Message_GetAcceptedStateSummary) isMessage_Message() {}

func (*Message_AcceptedStateSummary_) isMessage_Message() {}

func (*Message_GetAcceptedFrontier) isMessage_Message() {}

func (*Message_AcceptedFrontier_) isMessage_Message() {}

func (*Message_GetAccepted) isMessage_Message() {}

func (*Message_Accepted_) isMessage_Message() {}

func (*Message_GetAncestors) isMessage_Message() {}

func (*Message_Ancestors_) isMessage_Message() {}

func (*Message_Get) isMessage_Message() {}

func (*Message_Put) isMessage_Message() {}

func (*Message_PushQuery) isMessage_Message() {}

func (*Message_PullQuery) isMessage_Message() {}

func (*Message_Chits) isMessage_Message() {}

func (*Message_AppRequest) isMessage_Message() {}

func (*Message_AppResponse) isMessage_Message() {}

func (*Message_AppGossip) isMessage_Message() {}

func (*Message_AppError) isMessage_Message() {}

func (*Message_Simplex) isMessage_Message() {}

// Ping reports a peer's perceived uptime percentage.
//
// Peers should respond to Ping with a Pong.
type Ping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Uptime percentage on the primary network [0, 100]
	Uptime        uint32 `protobuf:"varint,1,opt,name=uptime,proto3" json:"uptime,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ping) Reset() {
	*x = Ping{}
	mi := &file_p2p_p2p_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ping) ProtoMessage() {}

func (x *Ping) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ping.ProtoReflect.Descriptor instead.
func (*Ping) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{1}
}

func (x *Ping) GetUptime() uint32 {
	if x != nil {
		return x.Uptime
	}
	return 0
}

// Pong is sent in response to a Ping.
type Pong struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Pong) Reset() {
	*x = Pong{}
	mi := &file_p2p_p2p_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Pong) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pong) ProtoMessage() {}

func (x *Pong) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pong.ProtoReflect.Descriptor instead.
func (*Pong) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{2}
}

// Handshake is the first outbound message sent to a peer when a connection is
// established to start the p2p handshake.
//
// Peers must respond to a Handshake message with a PeerList message to allow the
// peer to connect to other peers in the network.
//
// Peers should drop connections to peers with incompatible versions.
type Handshake struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Network the peer is running on (e.g local, testnet, mainnet)
	NetworkId uint32 `protobuf:"varint,1,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	// Unix timestamp when this Handshake message was created
	MyTime uint64 `protobuf:"varint,2,opt,name=my_time,json=myTime,proto3" json:"my_time,omitempty"`
	// IP address of the peer
	IpAddr []byte `protobuf:"bytes,3,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// IP port of the peer
	IpPort uint32 `protobuf:"varint,4,opt,name=ip_port,json=ipPort,proto3" json:"ip_port,omitempty"`
	// Timestamp of the IP
	IpSigningTime uint64 `protobuf:"varint,6,opt,name=ip_signing_time,json=ipSigningTime,proto3" json:"ip_signing_time,omitempty"`
	// Signature of the peer IP port pair at a provided timestamp with the TLS
	// key.
	IpNodeIdSig []byte `protobuf:"bytes,7,opt,name=ip_node_id_sig,json=ipNodeIdSig,proto3" json:"ip_node_id_sig,omitempty"`
	// Subnets the peer is tracking
	TrackedSubnets [][]byte     `protobuf:"bytes,8,rep,name=tracked_subnets,json=trackedSubnets,proto3" json:"tracked_subnets,omitempty"`
	Client         *Client      `protobuf:"bytes,9,opt,name=client,proto3" json:"client,omitempty"`
	SupportedAcps  []uint32     `protobuf:"varint,10,rep,packed,name=supported_acps,json=supportedAcps,proto3" json:"supported_acps,omitempty"`
	ObjectedAcps   []uint32     `protobuf:"varint,11,rep,packed,name=objected_acps,json=objectedAcps,proto3" json:"objected_acps,omitempty"`
	KnownPeers     *BloomFilter `protobuf:"bytes,12,opt,name=known_peers,json=knownPeers,proto3" json:"known_peers,omitempty"`
	// Signature of the peer IP port pair at a provided timestamp with the BLS
	// key.
	IpBlsSig []byte `protobuf:"bytes,13,opt,name=ip_bls_sig,json=ipBlsSig,proto3" json:"ip_bls_sig,omitempty"`
	// To avoid sending IPs that the client isn't interested in tracking, the
	// server expects the client to confirm that it is tracking all subnets.
	AllSubnets    bool `protobuf:"varint,14,opt,name=all_subnets,json=allSubnets,proto3" json:"all_subnets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Handshake) Reset() {
	*x = Handshake{}
	mi := &file_p2p_p2p_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Handshake) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Handshake) ProtoMessage() {}

func (x *Handshake) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Handshake.ProtoReflect.Descriptor instead.
func (*Handshake) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{3}
}

func (x *Handshake) GetNetworkId() uint32 {
	if x != nil {
		return x.NetworkId
	}
	return 0
}

func (x *Handshake) GetMyTime() uint64 {
	if x != nil {
		return x.MyTime
	}
	return 0
}

func (x *Handshake) GetIpAddr() []byte {
	if x != nil {
		return x.IpAddr
	}
	return nil
}

func (x *Handshake) GetIpPort() uint32 {
	if x != nil {
		return x.IpPort
	}
	return 0
}

func (x *Handshake) GetIpSigningTime() uint64 {
	if x != nil {
		return x.IpSigningTime
	}
	return 0
}

func (x *Handshake) GetIpNodeIdSig() []byte {
	if x != nil {
		return x.IpNodeIdSig
	}
	return nil
}

func (x *Handshake) GetTrackedSubnets() [][]byte {
	if x != nil {
		return x.TrackedSubnets
	}
	return nil
}

func (x *Handshake) GetClient() *Client {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *Handshake) GetSupportedAcps() []uint32 {
	if x != nil {
		return x.SupportedAcps
	}
	return nil
}

func (x *Handshake) GetObjectedAcps() []uint32 {
	if x != nil {
		return x.ObjectedAcps
	}
	return nil
}

func (x *Handshake) GetKnownPeers() *BloomFilter {
	if x != nil {
		return x.KnownPeers
	}
	return nil
}

func (x *Handshake) GetIpBlsSig() []byte {
	if x != nil {
		return x.IpBlsSig
	}
	return nil
}

func (x *Handshake) GetAllSubnets() bool {
	if x != nil {
		return x.AllSubnets
	}
	return false
}

// Metadata about a peer's P2P client used to determine compatibility
type Client struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client name (e.g avalanchego)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Client semantic version
	Major         uint32 `protobuf:"varint,2,opt,name=major,proto3" json:"major,omitempty"`
	Minor         uint32 `protobuf:"varint,3,opt,name=minor,proto3" json:"minor,omitempty"`
	Patch         uint32 `protobuf:"varint,4,opt,name=patch,proto3" json:"patch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Client) Reset() {
	*x = Client{}
	mi := &file_p2p_p2p_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Client) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Client) ProtoMessage() {}

func (x *Client) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Client.ProtoReflect.Descriptor instead.
func (*Client) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{4}
}

func (x *Client) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Client) GetMajor() uint32 {
	if x != nil {
		return x.Major
	}
	return 0
}

func (x *Client) GetMinor() uint32 {
	if x != nil {
		return x.Minor
	}
	return 0
}

func (x *Client) GetPatch() uint32 {
	if x != nil {
		return x.Patch
	}
	return 0
}

// BloomFilter with a random salt to prevent consistent hash collisions
type BloomFilter struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Filter        []byte                 `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Salt          []byte                 `protobuf:"bytes,2,opt,name=salt,proto3" json:"salt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BloomFilter) Reset() {
	*x = BloomFilter{}
	mi := &file_p2p_p2p_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BloomFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BloomFilter) ProtoMessage() {}

func (x *BloomFilter) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BloomFilter.ProtoReflect.Descriptor instead.
func (*BloomFilter) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{5}
}

func (x *BloomFilter) GetFilter() []byte {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *BloomFilter) GetSalt() []byte {
	if x != nil {
		return x.Salt
	}
	return nil
}

// ClaimedIpPort contains metadata needed to connect to a peer
type ClaimedIpPort struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// X509 certificate of the peer
	X509Certificate []byte `protobuf:"bytes,1,opt,name=x509_certificate,json=x509Certificate,proto3" json:"x509_certificate,omitempty"`
	// IP address of the peer
	IpAddr []byte `protobuf:"bytes,2,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	// IP port of the peer
	IpPort uint32 `protobuf:"varint,3,opt,name=ip_port,json=ipPort,proto3" json:"ip_port,omitempty"`
	// Timestamp of the IP address + port pair
	Timestamp uint64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Signature of the IP port pair at a provided timestamp
	Signature []byte `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	// P-Chain transaction that added this peer to the validator set
	TxId          []byte `protobuf:"bytes,6,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClaimedIpPort) Reset() {
	*x = ClaimedIpPort{}
	mi := &file_p2p_p2p_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClaimedIpPort) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClaimedIpPort) ProtoMessage() {}

func (x *ClaimedIpPort) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClaimedIpPort.ProtoReflect.Descriptor instead.
func (*ClaimedIpPort) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{6}
}

func (x *ClaimedIpPort) GetX509Certificate() []byte {
	if x != nil {
		return x.X509Certificate
	}
	return nil
}

func (x *ClaimedIpPort) GetIpAddr() []byte {
	if x != nil {
		return x.IpAddr
	}
	return nil
}

func (x *ClaimedIpPort) GetIpPort() uint32 {
	if x != nil {
		return x.IpPort
	}
	return 0
}

func (x *ClaimedIpPort) GetTimestamp() uint64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ClaimedIpPort) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ClaimedIpPort) GetTxId() []byte {
	if x != nil {
		return x.TxId
	}
	return nil
}

// GetPeerList contains a bloom filter of the currently known validator IPs.
//
// GetPeerList must not be responded to until finishing the handshake. After the
// handshake is completed, GetPeerlist messages should be responded to with a
// Peerlist message containing validators that are not present in the bloom
// filter.
type GetPeerList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	KnownPeers    *BloomFilter           `protobuf:"bytes,1,opt,name=known_peers,json=knownPeers,proto3" json:"known_peers,omitempty"`
	AllSubnets    bool                   `protobuf:"varint,2,opt,name=all_subnets,json=allSubnets,proto3" json:"all_subnets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPeerList) Reset() {
	*x = GetPeerList{}
	mi := &file_p2p_p2p_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPeerList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPeerList) ProtoMessage() {}

func (x *GetPeerList) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPeerList.ProtoReflect.Descriptor instead.
func (*GetPeerList) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{7}
}

func (x *GetPeerList) GetKnownPeers() *BloomFilter {
	if x != nil {
		return x.KnownPeers
	}
	return nil
}

func (x *GetPeerList) GetAllSubnets() bool {
	if x != nil {
		return x.AllSubnets
	}
	return false
}

// PeerList contains network-level metadata for a set of validators.
//
// PeerList must be sent in response to an inbound Handshake message from a
// remote peer a peer wants to connect to. Once a PeerList is received after
// a Handshake message, the p2p handshake is complete and the connection is
// established.
//
// PeerList should be sent in response to a GetPeerlist message if the handshake
// has been completed.
type PeerList struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ClaimedIpPorts []*ClaimedIpPort       `protobuf:"bytes,1,rep,name=claimed_ip_ports,json=claimedIpPorts,proto3" json:"claimed_ip_ports,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *PeerList) Reset() {
	*x = PeerList{}
	mi := &file_p2p_p2p_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerList) ProtoMessage() {}

func (x *PeerList) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerList.ProtoReflect.Descriptor instead.
func (*PeerList) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{8}
}

func (x *PeerList) GetClaimedIpPorts() []*ClaimedIpPort {
	if x != nil {
		return x.ClaimedIpPorts
	}
	return nil
}

// GetStateSummaryFrontier requests a peer's most recently accepted state
// summary
type GetStateSummaryFrontier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline      uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStateSummaryFrontier) Reset() {
	*x = GetStateSummaryFrontier{}
	mi := &file_p2p_p2p_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStateSummaryFrontier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStateSummaryFrontier) ProtoMessage() {}

func (x *GetStateSummaryFrontier) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStateSummaryFrontier.ProtoReflect.Descriptor instead.
func (*GetStateSummaryFrontier) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{9}
}

func (x *GetStateSummaryFrontier) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *GetStateSummaryFrontier) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *GetStateSummaryFrontier) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

// StateSummaryFrontier is sent in response to a GetStateSummaryFrontier request
type StateSummaryFrontier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original GetStateSummaryFrontier request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The requested state summary
	Summary       []byte `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StateSummaryFrontier) Reset() {
	*x = StateSummaryFrontier{}
	mi := &file_p2p_p2p_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateSummaryFrontier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateSummaryFrontier) ProtoMessage() {}

func (x *StateSummaryFrontier) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateSummaryFrontier.ProtoReflect.Descriptor instead.
func (*StateSummaryFrontier) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{10}
}

func (x *StateSummaryFrontier) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *StateSummaryFrontier) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *StateSummaryFrontier) GetSummary() []byte {
	if x != nil {
		return x.Summary
	}
	return nil
}

// GetAcceptedStateSummary requests a set of state summaries at a set of
// block heights
type GetAcceptedStateSummary struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Heights being requested
	Heights       []uint64 `protobuf:"varint,4,rep,packed,name=heights,proto3" json:"heights,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAcceptedStateSummary) Reset() {
	*x = GetAcceptedStateSummary{}
	mi := &file_p2p_p2p_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAcceptedStateSummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAcceptedStateSummary) ProtoMessage() {}

func (x *GetAcceptedStateSummary) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAcceptedStateSummary.ProtoReflect.Descriptor instead.
func (*GetAcceptedStateSummary) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{11}
}

func (x *GetAcceptedStateSummary) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *GetAcceptedStateSummary) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *GetAcceptedStateSummary) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *GetAcceptedStateSummary) GetHeights() []uint64 {
	if x != nil {
		return x.Heights
	}
	return nil
}

// AcceptedStateSummary is sent in response to GetAcceptedStateSummary
type AcceptedStateSummary struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original GetAcceptedStateSummary request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// State summary ids
	SummaryIds    [][]byte `protobuf:"bytes,3,rep,name=summary_ids,json=summaryIds,proto3" json:"summary_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AcceptedStateSummary) Reset() {
	*x = AcceptedStateSummary{}
	mi := &file_p2p_p2p_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AcceptedStateSummary) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AcceptedStateSummary) ProtoMessage() {}

func (x *AcceptedStateSummary) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AcceptedStateSummary.ProtoReflect.Descriptor instead.
func (*AcceptedStateSummary) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{12}
}

func (x *AcceptedStateSummary) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AcceptedStateSummary) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *AcceptedStateSummary) GetSummaryIds() [][]byte {
	if x != nil {
		return x.SummaryIds
	}
	return nil
}

// GetAcceptedFrontier requests the accepted frontier from a peer.
//
// Peers should respond to GetAcceptedFrontier with AcceptedFrontier.
type GetAcceptedFrontier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline      uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAcceptedFrontier) Reset() {
	*x = GetAcceptedFrontier{}
	mi := &file_p2p_p2p_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAcceptedFrontier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAcceptedFrontier) ProtoMessage() {}

func (x *GetAcceptedFrontier) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAcceptedFrontier.ProtoReflect.Descriptor instead.
func (*GetAcceptedFrontier) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{13}
}

func (x *GetAcceptedFrontier) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *GetAcceptedFrontier) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *GetAcceptedFrontier) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

// AcceptedFrontier contains the remote peer's last accepted frontier.
//
// AcceptedFrontier is sent in response to GetAcceptedFrontier.
type AcceptedFrontier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original GetAcceptedFrontier request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// The id of the last accepted frontier
	ContainerId   []byte `protobuf:"bytes,3,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AcceptedFrontier) Reset() {
	*x = AcceptedFrontier{}
	mi := &file_p2p_p2p_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AcceptedFrontier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AcceptedFrontier) ProtoMessage() {}

func (x *AcceptedFrontier) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AcceptedFrontier.ProtoReflect.Descriptor instead.
func (*AcceptedFrontier) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{14}
}

func (x *AcceptedFrontier) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AcceptedFrontier) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *AcceptedFrontier) GetContainerId() []byte {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

// GetAccepted sends a request with the sender's accepted frontier to a remote
// peer.
//
// Peers should respond to GetAccepted with an Accepted message.
type GetAccepted struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this message
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// The sender's accepted frontier
	ContainerIds  [][]byte `protobuf:"bytes,4,rep,name=container_ids,json=containerIds,proto3" json:"container_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAccepted) Reset() {
	*x = GetAccepted{}
	mi := &file_p2p_p2p_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAccepted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAccepted) ProtoMessage() {}

func (x *GetAccepted) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAccepted.ProtoReflect.Descriptor instead.
func (*GetAccepted) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{15}
}

func (x *GetAccepted) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *GetAccepted) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *GetAccepted) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *GetAccepted) GetContainerIds() [][]byte {
	if x != nil {
		return x.ContainerIds
	}
	return nil
}

// Accepted is sent in response to GetAccepted. The sending peer responds with
// a subset of container ids from the GetAccepted request that the sending peer
// has accepted.
type Accepted struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original GetAccepted request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Subset of container ids from the GetAccepted request that the sender has
	// accepted
	ContainerIds  [][]byte `protobuf:"bytes,3,rep,name=container_ids,json=containerIds,proto3" json:"container_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Accepted) Reset() {
	*x = Accepted{}
	mi := &file_p2p_p2p_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Accepted) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Accepted) ProtoMessage() {}

func (x *Accepted) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Accepted.ProtoReflect.Descriptor instead.
func (*Accepted) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{16}
}

func (x *Accepted) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Accepted) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Accepted) GetContainerIds() [][]byte {
	if x != nil {
		return x.ContainerIds
	}
	return nil
}

// GetAncestors requests the ancestors for a given container.
//
// The remote peer should respond with an Ancestors message.
type GetAncestors struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Container for which ancestors are being requested
	ContainerId []byte `protobuf:"bytes,4,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Consensus type to handle this message
	EngineType    EngineType `protobuf:"varint,5,opt,name=engine_type,json=engineType,proto3,enum=p2p.EngineType" json:"engine_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAncestors) Reset() {
	*x = GetAncestors{}
	mi := &file_p2p_p2p_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAncestors) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAncestors) ProtoMessage() {}

func (x *GetAncestors) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAncestors.ProtoReflect.Descriptor instead.
func (*GetAncestors) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{17}
}

func (x *GetAncestors) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *GetAncestors) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *GetAncestors) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *GetAncestors) GetContainerId() []byte {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *GetAncestors) GetEngineType() EngineType {
	if x != nil {
		return x.EngineType
	}
	return EngineType_ENGINE_TYPE_UNSPECIFIED
}

// Ancestors is sent in response to GetAncestors.
//
// Ancestors contains a contiguous ancestry of containers for the requested
// container in order of increasing block height.
type Ancestors struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original GetAncestors request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Ancestry for the requested container
	Containers    [][]byte `protobuf:"bytes,3,rep,name=containers,proto3" json:"containers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ancestors) Reset() {
	*x = Ancestors{}
	mi := &file_p2p_p2p_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ancestors) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ancestors) ProtoMessage() {}

func (x *Ancestors) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ancestors.ProtoReflect.Descriptor instead.
func (*Ancestors) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{18}
}

func (x *Ancestors) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Ancestors) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Ancestors) GetContainers() [][]byte {
	if x != nil {
		return x.Containers
	}
	return nil
}

// Get requests a container from a remote peer.
//
// Remote peers should respond with a Put message if they have the container.
type Get struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Container being requested
	ContainerId   []byte `protobuf:"bytes,4,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Get) Reset() {
	*x = Get{}
	mi := &file_p2p_p2p_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Get) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Get) ProtoMessage() {}

func (x *Get) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Get.ProtoReflect.Descriptor instead.
func (*Get) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{19}
}

func (x *Get) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Get) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Get) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *Get) GetContainerId() []byte {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

// Put is sent in response to Get with the requested block.
type Put struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original Get request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Requested container
	Container     []byte `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Put) Reset() {
	*x = Put{}
	mi := &file_p2p_p2p_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Put) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Put) ProtoMessage() {}

func (x *Put) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Put.ProtoReflect.Descriptor instead.
func (*Put) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{20}
}

func (x *Put) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Put) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Put) GetContainer() []byte {
	if x != nil {
		return x.Container
	}
	return nil
}

// PushQuery requests the preferences of a remote peer given a container.
//
// Remote peers should respond to a PushQuery with a Chits message
type PushQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Container being gossiped
	Container []byte `protobuf:"bytes,4,opt,name=container,proto3" json:"container,omitempty"`
	// Requesting peer's last accepted height
	RequestedHeight uint64 `protobuf:"varint,6,opt,name=requested_height,json=requestedHeight,proto3" json:"requested_height,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PushQuery) Reset() {
	*x = PushQuery{}
	mi := &file_p2p_p2p_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PushQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushQuery) ProtoMessage() {}

func (x *PushQuery) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushQuery.ProtoReflect.Descriptor instead.
func (*PushQuery) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{21}
}

func (x *PushQuery) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *PushQuery) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *PushQuery) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *PushQuery) GetContainer() []byte {
	if x != nil {
		return x.Container
	}
	return nil
}

func (x *PushQuery) GetRequestedHeight() uint64 {
	if x != nil {
		return x.RequestedHeight
	}
	return 0
}

// PullQuery requests the preferences of a remote peer given a container id.
//
// Remote peers should respond to a PullQuery with a Chits message
type PullQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Container id being gossiped
	ContainerId []byte `protobuf:"bytes,4,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	// Requesting peer's last accepted height
	RequestedHeight uint64 `protobuf:"varint,6,opt,name=requested_height,json=requestedHeight,proto3" json:"requested_height,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PullQuery) Reset() {
	*x = PullQuery{}
	mi := &file_p2p_p2p_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PullQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PullQuery) ProtoMessage() {}

func (x *PullQuery) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PullQuery.ProtoReflect.Descriptor instead.
func (*PullQuery) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{22}
}

func (x *PullQuery) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *PullQuery) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *PullQuery) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *PullQuery) GetContainerId() []byte {
	if x != nil {
		return x.ContainerId
	}
	return nil
}

func (x *PullQuery) GetRequestedHeight() uint64 {
	if x != nil {
		return x.RequestedHeight
	}
	return 0
}

// Chits contains the preferences of a peer in response to a PushQuery or
// PullQuery message.
type Chits struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request ID of the original PushQuery/PullQuery request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// ID of the currently preferred block
	PreferredId []byte `protobuf:"bytes,3,opt,name=preferred_id,json=preferredId,proto3" json:"preferred_id,omitempty"`
	// ID of the last accepted block
	AcceptedId []byte `protobuf:"bytes,4,opt,name=accepted_id,json=acceptedId,proto3" json:"accepted_id,omitempty"`
	// ID of the currently preferred block at the requested height
	PreferredIdAtHeight []byte `protobuf:"bytes,5,opt,name=preferred_id_at_height,json=preferredIdAtHeight,proto3" json:"preferred_id_at_height,omitempty"`
	// Last accepted block's height
	AcceptedHeight uint64 `protobuf:"varint,6,opt,name=accepted_height,json=acceptedHeight,proto3" json:"accepted_height,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Chits) Reset() {
	*x = Chits{}
	mi := &file_p2p_p2p_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Chits) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Chits) ProtoMessage() {}

func (x *Chits) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Chits.ProtoReflect.Descriptor instead.
func (*Chits) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{23}
}

func (x *Chits) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Chits) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *Chits) GetPreferredId() []byte {
	if x != nil {
		return x.PreferredId
	}
	return nil
}

func (x *Chits) GetAcceptedId() []byte {
	if x != nil {
		return x.AcceptedId
	}
	return nil
}

func (x *Chits) GetPreferredIdAtHeight() []byte {
	if x != nil {
		return x.PreferredIdAtHeight
	}
	return nil
}

func (x *Chits) GetAcceptedHeight() uint64 {
	if x != nil {
		return x.AcceptedHeight
	}
	return 0
}

// AppRequest is a VM-defined request.
//
// Remote peers must respond to AppRequest with a corresponding AppResponse or
// AppError
type AppRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being requested from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Unique identifier for this request
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Timeout (ns) for this request
	Deadline uint64 `protobuf:"varint,3,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// Request body
	AppBytes      []byte `protobuf:"bytes,4,opt,name=app_bytes,json=appBytes,proto3" json:"app_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppRequest) Reset() {
	*x = AppRequest{}
	mi := &file_p2p_p2p_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppRequest) ProtoMessage() {}

func (x *AppRequest) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppRequest.ProtoReflect.Descriptor instead.
func (*AppRequest) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{24}
}

func (x *AppRequest) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AppRequest) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *AppRequest) GetDeadline() uint64 {
	if x != nil {
		return x.Deadline
	}
	return 0
}

func (x *AppRequest) GetAppBytes() []byte {
	if x != nil {
		return x.AppBytes
	}
	return nil
}

// AppResponse is a VM-defined response sent in response to AppRequest
type AppResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain being responded from
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original AppRequest
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// Response body
	AppBytes      []byte `protobuf:"bytes,3,opt,name=app_bytes,json=appBytes,proto3" json:"app_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppResponse) Reset() {
	*x = AppResponse{}
	mi := &file_p2p_p2p_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppResponse) ProtoMessage() {}

func (x *AppResponse) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppResponse.ProtoReflect.Descriptor instead.
func (*AppResponse) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{25}
}

func (x *AppResponse) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AppResponse) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *AppResponse) GetAppBytes() []byte {
	if x != nil {
		return x.AppBytes
	}
	return nil
}

// AppError is a VM-defined error sent in response to AppRequest
type AppError struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain the message is for
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Request id of the original AppRequest
	RequestId uint32 `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	// VM defined error code. VMs may define error codes > 0.
	ErrorCode int32 `protobuf:"zigzag32,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// VM defined error message
	ErrorMessage  string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppError) Reset() {
	*x = AppError{}
	mi := &file_p2p_p2p_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppError) ProtoMessage() {}

func (x *AppError) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppError.ProtoReflect.Descriptor instead.
func (*AppError) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{26}
}

func (x *AppError) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AppError) GetRequestId() uint32 {
	if x != nil {
		return x.RequestId
	}
	return 0
}

func (x *AppError) GetErrorCode() int32 {
	if x != nil {
		return x.ErrorCode
	}
	return 0
}

func (x *AppError) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

// AppGossip is a VM-defined message
type AppGossip struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Chain the message is for
	ChainId []byte `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Message body
	AppBytes      []byte `protobuf:"bytes,2,opt,name=app_bytes,json=appBytes,proto3" json:"app_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppGossip) Reset() {
	*x = AppGossip{}
	mi := &file_p2p_p2p_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppGossip) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppGossip) ProtoMessage() {}

func (x *AppGossip) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppGossip.ProtoReflect.Descriptor instead.
func (*AppGossip) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{27}
}

func (x *AppGossip) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AppGossip) GetAppBytes() []byte {
	if x != nil {
		return x.AppBytes
	}
	return nil
}

type Simplex struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	ChainId []byte                 `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Types that are valid to be assigned to Message:
	//
	//	*Simplex_BlockProposal
	//	*Simplex_Vote
	//	*Simplex_EmptyVote
	//	*Simplex_FinalizeVote
	//	*Simplex_Notarization
	//	*Simplex_EmptyNotarization
	//	*Simplex_Finalization
	//	*Simplex_ReplicationRequest
	//	*Simplex_ReplicationResponse
	Message       isSimplex_Message `protobuf_oneof:"message"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Simplex) Reset() {
	*x = Simplex{}
	mi := &file_p2p_p2p_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Simplex) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Simplex) ProtoMessage() {}

func (x *Simplex) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Simplex.ProtoReflect.Descriptor instead.
func (*Simplex) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{28}
}

func (x *Simplex) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *Simplex) GetMessage() isSimplex_Message {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *Simplex) GetBlockProposal() *BlockProposal {
	if x != nil {
		if x, ok := x.Message.(*Simplex_BlockProposal); ok {
			return x.BlockProposal
		}
	}
	return nil
}

func (x *Simplex) GetVote() *Vote {
	if x != nil {
		if x, ok := x.Message.(*Simplex_Vote); ok {
			return x.Vote
		}
	}
	return nil
}

func (x *Simplex) GetEmptyVote() *EmptyVote {
	if x != nil {
		if x, ok := x.Message.(*Simplex_EmptyVote); ok {
			return x.EmptyVote
		}
	}
	return nil
}

func (x *Simplex) GetFinalizeVote() *Vote {
	if x != nil {
		if x, ok := x.Message.(*Simplex_FinalizeVote); ok {
			return x.FinalizeVote
		}
	}
	return nil
}

func (x *Simplex) GetNotarization() *QuorumCertificate {
	if x != nil {
		if x, ok := x.Message.(*Simplex_Notarization); ok {
			return x.Notarization
		}
	}
	return nil
}

func (x *Simplex) GetEmptyNotarization() *EmptyNotarization {
	if x != nil {
		if x, ok := x.Message.(*Simplex_EmptyNotarization); ok {
			return x.EmptyNotarization
		}
	}
	return nil
}

func (x *Simplex) GetFinalization() *QuorumCertificate {
	if x != nil {
		if x, ok := x.Message.(*Simplex_Finalization); ok {
			return x.Finalization
		}
	}
	return nil
}

func (x *Simplex) GetReplicationRequest() *ReplicationRequest {
	if x != nil {
		if x, ok := x.Message.(*Simplex_ReplicationRequest); ok {
			return x.ReplicationRequest
		}
	}
	return nil
}

func (x *Simplex) GetReplicationResponse() *ReplicationResponse {
	if x != nil {
		if x, ok := x.Message.(*Simplex_ReplicationResponse); ok {
			return x.ReplicationResponse
		}
	}
	return nil
}

type isSimplex_Message interface {
	isSimplex_Message()
}

type Simplex_BlockProposal struct {
	BlockProposal *BlockProposal `protobuf:"bytes,2,opt,name=block_proposal,json=blockProposal,proto3,oneof"`
}

type Simplex_Vote struct {
	Vote *Vote `protobuf:"bytes,3,opt,name=vote,proto3,oneof"`
}

type Simplex_EmptyVote struct {
	EmptyVote *EmptyVote `protobuf:"bytes,4,opt,name=empty_vote,json=emptyVote,proto3,oneof"`
}

type Simplex_FinalizeVote struct {
	FinalizeVote *Vote `protobuf:"bytes,5,opt,name=finalize_vote,json=finalizeVote,proto3,oneof"`
}

type Simplex_Notarization struct {
	Notarization *QuorumCertificate `protobuf:"bytes,6,opt,name=notarization,proto3,oneof"`
}

type Simplex_EmptyNotarization struct {
	EmptyNotarization *EmptyNotarization `protobuf:"bytes,7,opt,name=empty_notarization,json=emptyNotarization,proto3,oneof"`
}

type Simplex_Finalization struct {
	Finalization *QuorumCertificate `protobuf:"bytes,8,opt,name=finalization,proto3,oneof"`
}

type Simplex_ReplicationRequest struct {
	ReplicationRequest *ReplicationRequest `protobuf:"bytes,9,opt,name=replication_request,json=replicationRequest,proto3,oneof"`
}

type Simplex_ReplicationResponse struct {
	ReplicationResponse *ReplicationResponse `protobuf:"bytes,10,opt,name=replication_response,json=replicationResponse,proto3,oneof"`
}

func (*Simplex_BlockProposal) isSimplex_Message() {}

func (*Simplex_Vote) isSimplex_Message() {}

func (*Simplex_EmptyVote) isSimplex_Message() {}

func (*Simplex_FinalizeVote) isSimplex_Message() {}

func (*Simplex_Notarization) isSimplex_Message() {}

func (*Simplex_EmptyNotarization) isSimplex_Message() {}

func (*Simplex_Finalization) isSimplex_Message() {}

func (*Simplex_ReplicationRequest) isSimplex_Message() {}

func (*Simplex_ReplicationResponse) isSimplex_Message() {}

type BlockProposal struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Block         []byte                 `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Vote          *Vote                  `protobuf:"bytes,2,opt,name=vote,proto3" json:"vote,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockProposal) Reset() {
	*x = BlockProposal{}
	mi := &file_p2p_p2p_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockProposal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockProposal) ProtoMessage() {}

func (x *BlockProposal) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockProposal.ProtoReflect.Descriptor instead.
func (*BlockProposal) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{29}
}

func (x *BlockProposal) GetBlock() []byte {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *BlockProposal) GetVote() *Vote {
	if x != nil {
		return x.Vote
	}
	return nil
}

type ProtocolMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version defines the version of the protocol this block was created with.
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	// Epoch returns the epoch in which the block was proposed
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Round returns the round number in which the block was proposed.
	Round uint64 `protobuf:"varint,3,opt,name=round,proto3" json:"round,omitempty"`
	// Seq is the order of the block among all blocks in the blockchain.
	// Cannot correspond to an empty block.
	Seq uint64 `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	// Prev returns the digest of the previous data block
	Prev          []byte `protobuf:"bytes,5,opt,name=prev,proto3" json:"prev,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtocolMetadata) Reset() {
	*x = ProtocolMetadata{}
	mi := &file_p2p_p2p_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtocolMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtocolMetadata) ProtoMessage() {}

func (x *ProtocolMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtocolMetadata.ProtoReflect.Descriptor instead.
func (*ProtocolMetadata) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{30}
}

func (x *ProtocolMetadata) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *ProtocolMetadata) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *ProtocolMetadata) GetRound() uint64 {
	if x != nil {
		return x.Round
	}
	return 0
}

func (x *ProtocolMetadata) GetSeq() uint64 {
	if x != nil {
		return x.Seq
	}
	return 0
}

func (x *ProtocolMetadata) GetPrev() []byte {
	if x != nil {
		return x.Prev
	}
	return nil
}

type EmptyVoteMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Epoch returns the epoch in which the empty block was proposed
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Round returns the round number in which the empty block was proposed.
	Round         uint64 `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmptyVoteMetadata) Reset() {
	*x = EmptyVoteMetadata{}
	mi := &file_p2p_p2p_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptyVoteMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptyVoteMetadata) ProtoMessage() {}

func (x *EmptyVoteMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptyVoteMetadata.ProtoReflect.Descriptor instead.
func (*EmptyVoteMetadata) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{31}
}

func (x *EmptyVoteMetadata) GetEpoch() uint64 {
	if x != nil {
		return x.Epoch
	}
	return 0
}

func (x *EmptyVoteMetadata) GetRound() uint64 {
	if x != nil {
		return x.Round
	}
	return 0
}

type BlockHeader struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *ProtocolMetadata      `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// digest is the short representation of the inner block's bytes
	Digest        []byte `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockHeader) Reset() {
	*x = BlockHeader{}
	mi := &file_p2p_p2p_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockHeader) ProtoMessage() {}

func (x *BlockHeader) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockHeader.ProtoReflect.Descriptor instead.
func (*BlockHeader) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{32}
}

func (x *BlockHeader) GetMetadata() *ProtocolMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *BlockHeader) GetDigest() []byte {
	if x != nil {
		return x.Digest
	}
	return nil
}

type Signature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Signer identifies who the signature came from.
	Signer []byte `protobuf:"bytes,1,opt,name=signer,proto3" json:"signer,omitempty"`
	// Value is the actual cryptographic signature.
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Signature) Reset() {
	*x = Signature{}
	mi := &file_p2p_p2p_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Signature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Signature) ProtoMessage() {}

func (x *Signature) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Signature.ProtoReflect.Descriptor instead.
func (*Signature) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{33}
}

func (x *Signature) GetSigner() []byte {
	if x != nil {
		return x.Signer
	}
	return nil
}

func (x *Signature) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type Vote struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BlockHeader   *BlockHeader           `protobuf:"bytes,1,opt,name=block_header,json=blockHeader,proto3" json:"block_header,omitempty"`
	Signature     *Signature             `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Vote) Reset() {
	*x = Vote{}
	mi := &file_p2p_p2p_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Vote) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Vote) ProtoMessage() {}

func (x *Vote) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Vote.ProtoReflect.Descriptor instead.
func (*Vote) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{34}
}

func (x *Vote) GetBlockHeader() *BlockHeader {
	if x != nil {
		return x.BlockHeader
	}
	return nil
}

func (x *Vote) GetSignature() *Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

type EmptyVote struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *EmptyVoteMetadata     `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Signature     *Signature             `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EmptyVote) Reset() {
	*x = EmptyVote{}
	mi := &file_p2p_p2p_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptyVote) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptyVote) ProtoMessage() {}

func (x *EmptyVote) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptyVote.ProtoReflect.Descriptor instead.
func (*EmptyVote) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{35}
}

func (x *EmptyVote) GetMetadata() *EmptyVoteMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EmptyVote) GetSignature() *Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

type QuorumCertificate struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	BlockHeader       *BlockHeader           `protobuf:"bytes,1,opt,name=block_header,json=blockHeader,proto3" json:"block_header,omitempty"`
	QuorumCertificate []byte                 `protobuf:"bytes,2,opt,name=quorum_certificate,json=quorumCertificate,proto3" json:"quorum_certificate,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QuorumCertificate) Reset() {
	*x = QuorumCertificate{}
	mi := &file_p2p_p2p_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuorumCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuorumCertificate) ProtoMessage() {}

func (x *QuorumCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuorumCertificate.ProtoReflect.Descriptor instead.
func (*QuorumCertificate) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{36}
}

func (x *QuorumCertificate) GetBlockHeader() *BlockHeader {
	if x != nil {
		return x.BlockHeader
	}
	return nil
}

func (x *QuorumCertificate) GetQuorumCertificate() []byte {
	if x != nil {
		return x.QuorumCertificate
	}
	return nil
}

type EmptyNotarization struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Metadata          *EmptyVoteMetadata     `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	QuorumCertificate []byte                 `protobuf:"bytes,2,opt,name=quorum_certificate,json=quorumCertificate,proto3" json:"quorum_certificate,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *EmptyNotarization) Reset() {
	*x = EmptyNotarization{}
	mi := &file_p2p_p2p_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EmptyNotarization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EmptyNotarization) ProtoMessage() {}

func (x *EmptyNotarization) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EmptyNotarization.ProtoReflect.Descriptor instead.
func (*EmptyNotarization) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{37}
}

func (x *EmptyNotarization) GetMetadata() *EmptyVoteMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EmptyNotarization) GetQuorumCertificate() []byte {
	if x != nil {
		return x.QuorumCertificate
	}
	return nil
}

type ReplicationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Seqs          []uint64               `protobuf:"varint,1,rep,packed,name=seqs,proto3" json:"seqs,omitempty"`                           // sequences we are requesting
	LatestRound   uint64                 `protobuf:"varint,2,opt,name=latest_round,json=latestRound,proto3" json:"latest_round,omitempty"` // latest round that we are aware of
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationRequest) Reset() {
	*x = ReplicationRequest{}
	mi := &file_p2p_p2p_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationRequest) ProtoMessage() {}

func (x *ReplicationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationRequest.ProtoReflect.Descriptor instead.
func (*ReplicationRequest) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{38}
}

func (x *ReplicationRequest) GetSeqs() []uint64 {
	if x != nil {
		return x.Seqs
	}
	return nil
}

func (x *ReplicationRequest) GetLatestRound() uint64 {
	if x != nil {
		return x.LatestRound
	}
	return 0
}

type ReplicationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []*QuorumRound         `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`                                  // requested seqs. not required to be in particular order
	LatestRound   *QuorumRound           `protobuf:"bytes,2,opt,name=latest_round,json=latestRound,proto3" json:"latest_round,omitempty"` // latest round the responding node is aware of
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplicationResponse) Reset() {
	*x = ReplicationResponse{}
	mi := &file_p2p_p2p_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplicationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplicationResponse) ProtoMessage() {}

func (x *ReplicationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplicationResponse.ProtoReflect.Descriptor instead.
func (*ReplicationResponse) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{39}
}

func (x *ReplicationResponse) GetData() []*QuorumRound {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *ReplicationResponse) GetLatestRound() *QuorumRound {
	if x != nil {
		return x.LatestRound
	}
	return nil
}

// QuorumRound represents a round that has acheived quorum on either
// (empty notarization), (block & notarization), or (block, finalization certificate)
type QuorumRound struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Block             []byte                 `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Notarization      *QuorumCertificate     `protobuf:"bytes,2,opt,name=notarization,proto3" json:"notarization,omitempty"`
	EmptyNotarization *EmptyNotarization     `protobuf:"bytes,3,opt,name=empty_notarization,json=emptyNotarization,proto3" json:"empty_notarization,omitempty"`
	Finalization      *QuorumCertificate     `protobuf:"bytes,4,opt,name=finalization,proto3" json:"finalization,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *QuorumRound) Reset() {
	*x = QuorumRound{}
	mi := &file_p2p_p2p_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuorumRound) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuorumRound) ProtoMessage() {}

func (x *QuorumRound) ProtoReflect() protoreflect.Message {
	mi := &file_p2p_p2p_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuorumRound.ProtoReflect.Descriptor instead.
func (*QuorumRound) Descriptor() ([]byte, []int) {
	return file_p2p_p2p_proto_rawDescGZIP(), []int{40}
}

func (x *QuorumRound) GetBlock() []byte {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *QuorumRound) GetNotarization() *QuorumCertificate {
	if x != nil {
		return x.Notarization
	}
	return nil
}

func (x *QuorumRound) GetEmptyNotarization() *EmptyNotarization {
	if x != nil {
		return x.EmptyNotarization
	}
	return nil
}

func (x *QuorumRound) GetFinalization() *QuorumCertificate {
	if x != nil {
		return x.Finalization
	}
	return nil
}

var File_p2p_p2p_proto protoreflect.FileDescriptor

const file_p2p_p2p_proto_rawDesc = "" +
	"\n" +
	"\rp2p/p2p.proto\x12\x03p2p\"\x9d\v\n" +
	"\aMessage\x12)\n" +
	"\x0fcompressed_zstd\x18\x02 \x01(\fH\x00R\x0ecompressedZstd\x12\x1f\n" +
	"\x04ping\x18\v \x01(\v2\t.p2p.PingH\x00R\x04ping\x12\x1f\n" +
	"\x04pong\x18\f \x01(\v2\t.p2p.PongH\x00R\x04pong\x12.\n" +
	"\thandshake\x18\r \x01(\v2\x0e.p2p.HandshakeH\x00R\thandshake\x126\n" +
	"\rget_peer_list\x18# \x01(\v2\x10.p2p.GetPeerListH\x00R\vgetPeerList\x12,\n" +
	"\tpeer_list\x18\x0e \x01(\v2\r.p2p.PeerListH\x00R\bpeerList\x12[\n" +
	"\x1aget_state_summary_frontier\x18\x0f \x01(\v2\x1c.p2p.GetStateSummaryFrontierH\x00R\x17getStateSummaryFrontier\x12Q\n" +
	"\x16state_summary_frontier\x18\x10 \x01(\v2\x19.p2p.StateSummaryFrontierH\x00R\x14stateSummaryFrontier\x12[\n" +
	"\x1aget_accepted_state_summary\x18\x11 \x01(\v2\x1c.p2p.GetAcceptedStateSummaryH\x00R\x17getAcceptedStateSummary\x12Q\n" +
	"\x16accepted_state_summary\x18\x12 \x01(\v2\x19.p2p.AcceptedStateSummaryH\x00R\x14acceptedStateSummary\x12N\n" +
	"\x15get_accepted_frontier\x18\x13 \x01(\v2\x18.p2p.GetAcceptedFrontierH\x00R\x13getAcceptedFrontier\x12D\n" +
	"\x11accepted_frontier\x18\x14 \x01(\v2\x15.p2p.AcceptedFrontierH\x00R\x10acceptedFrontier\x125\n" +
	"\fget_accepted\x18\x15 \x01(\v2\x10.p2p.GetAcceptedH\x00R\vgetAccepted\x12+\n" +
	"\baccepted\x18\x16 \x01(\v2\r.p2p.AcceptedH\x00R\baccepted\x128\n" +
	"\rget_ancestors\x18\x17 \x01(\v2\x11.p2p.GetAncestorsH\x00R\fgetAncestors\x12.\n" +
	"\tancestors\x18\x18 \x01(\v2\x0e.p2p.AncestorsH\x00R\tancestors\x12\x1c\n" +
	"\x03get\x18\x19 \x01(\v2\b.p2p.GetH\x00R\x03get\x12\x1c\n" +
	"\x03put\x18\x1a \x01(\v2\b.p2p.PutH\x00R\x03put\x12/\n" +
	"\n" +
	"push_query\x18\x1b \x01(\v2\x0e.p2p.PushQueryH\x00R\tpushQuery\x12/\n" +
	"\n" +
	"pull_query\x18\x1c \x01(\v2\x0e.p2p.PullQueryH\x00R\tpullQuery\x12\"\n" +
	"\x05chits\x18\x1d \x01(\v2\n" +
	".p2p.ChitsH\x00R\x05chits\x122\n" +
	"\vapp_request\x18\x1e \x01(\v2\x0f.p2p.AppRequestH\x00R\n" +
	"appRequest\x125\n" +
	"\fapp_response\x18\x1f \x01(\v2\x10.p2p.AppResponseH\x00R\vappResponse\x12/\n" +
	"\n" +
	"app_gossip\x18  \x01(\v2\x0e.p2p.AppGossipH\x00R\tappGossip\x12,\n" +
	"\tapp_error\x18\" \x01(\v2\r.p2p.AppErrorH\x00R\bappError\x12(\n" +
	"\asimplex\x18$ \x01(\v2\f.p2p.SimplexH\x00R\asimplexB\t\n" +
	"\amessageJ\x04\b\x01\x10\x02J\x04\b%\x10&\"$\n" +
	"\x04Ping\x12\x16\n" +
	"\x06uptime\x18\x01 \x01(\rR\x06uptimeJ\x04\b\x02\x10\x03\"\x12\n" +
	"\x04PongJ\x04\b\x01\x10\x02J\x04\b\x02\x10\x03\"\xd4\x03\n" +
	"\tHandshake\x12\x1d\n" +
	"\n" +
	"network_id\x18\x01 \x01(\rR\tnetworkId\x12\x17\n" +
	"\amy_time\x18\x02 \x01(\x04R\x06myTime\x12\x17\n" +
	"\aip_addr\x18\x03 \x01(\fR\x06ipAddr\x12\x17\n" +
	"\aip_port\x18\x04 \x01(\rR\x06ipPort\x12&\n" +
	"\x0fip_signing_time\x18\x06 \x01(\x04R\ripSigningTime\x12#\n" +
	"\x0eip_node_id_sig\x18\a \x01(\fR\vipNodeIdSig\x12'\n" +
	"\x0ftracked_subnets\x18\b \x03(\fR\x0etrackedSubnets\x12#\n" +
	"\x06client\x18\t \x01(\v2\v.p2p.ClientR\x06client\x12%\n" +
	"\x0esupported_acps\x18\n" +
	" \x03(\rR\rsupportedAcps\x12#\n" +
	"\robjected_acps\x18\v \x03(\rR\fobjectedAcps\x121\n" +
	"\vknown_peers\x18\f \x01(\v2\x10.p2p.BloomFilterR\n" +
	"knownPeers\x12\x1c\n" +
	"\n" +
	"ip_bls_sig\x18\r \x01(\fR\bipBlsSig\x12\x1f\n" +
	"\vall_subnets\x18\x0e \x01(\bR\n" +
	"allSubnetsJ\x04\b\x05\x10\x06\"^\n" +
	"\x06Client\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05major\x18\x02 \x01(\rR\x05major\x12\x14\n" +
	"\x05minor\x18\x03 \x01(\rR\x05minor\x12\x14\n" +
	"\x05patch\x18\x04 \x01(\rR\x05patch\"9\n" +
	"\vBloomFilter\x12\x16\n" +
	"\x06filter\x18\x01 \x01(\fR\x06filter\x12\x12\n" +
	"\x04salt\x18\x02 \x01(\fR\x04salt\"\xbd\x01\n" +
	"\rClaimedIpPort\x12)\n" +
	"\x10x509_certificate\x18\x01 \x01(\fR\x0fx509Certificate\x12\x17\n" +
	"\aip_addr\x18\x02 \x01(\fR\x06ipAddr\x12\x17\n" +
	"\aip_port\x18\x03 \x01(\rR\x06ipPort\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x04R\ttimestamp\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\fR\tsignature\x12\x13\n" +
	"\x05tx_id\x18\x06 \x01(\fR\x04txId\"a\n" +
	"\vGetPeerList\x121\n" +
	"\vknown_peers\x18\x01 \x01(\v2\x10.p2p.BloomFilterR\n" +
	"knownPeers\x12\x1f\n" +
	"\vall_subnets\x18\x02 \x01(\bR\n" +
	"allSubnets\"H\n" +
	"\bPeerList\x12<\n" +
	"\x10claimed_ip_ports\x18\x01 \x03(\v2\x12.p2p.ClaimedIpPortR\x0eclaimedIpPorts\"o\n" +
	"\x17GetStateSummaryFrontier\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\"j\n" +
	"\x14StateSummaryFrontier\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x18\n" +
	"\asummary\x18\x03 \x01(\fR\asummary\"\x89\x01\n" +
	"\x17GetAcceptedStateSummary\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12\x18\n" +
	"\aheights\x18\x04 \x03(\x04R\aheights\"q\n" +
	"\x14AcceptedStateSummary\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1f\n" +
	"\vsummary_ids\x18\x03 \x03(\fR\n" +
	"summaryIds\"q\n" +
	"\x13GetAcceptedFrontier\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadlineJ\x04\b\x04\x10\x05\"o\n" +
	"\x10AcceptedFrontier\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12!\n" +
	"\fcontainer_id\x18\x03 \x01(\fR\vcontainerId\"\x8e\x01\n" +
	"\vGetAccepted\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12#\n" +
	"\rcontainer_ids\x18\x04 \x03(\fR\fcontainerIdsJ\x04\b\x05\x10\x06\"i\n" +
	"\bAccepted\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12#\n" +
	"\rcontainer_ids\x18\x03 \x03(\fR\fcontainerIds\"\xb9\x01\n" +
	"\fGetAncestors\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12!\n" +
	"\fcontainer_id\x18\x04 \x01(\fR\vcontainerId\x120\n" +
	"\vengine_type\x18\x05 \x01(\x0e2\x0f.p2p.EngineTypeR\n" +
	"engineType\"e\n" +
	"\tAncestors\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1e\n" +
	"\n" +
	"containers\x18\x03 \x03(\fR\n" +
	"containers\"\x84\x01\n" +
	"\x03Get\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12!\n" +
	"\fcontainer_id\x18\x04 \x01(\fR\vcontainerIdJ\x04\b\x05\x10\x06\"]\n" +
	"\x03Put\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1c\n" +
	"\tcontainer\x18\x03 \x01(\fR\tcontainer\"\xb0\x01\n" +
	"\tPushQuery\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12\x1c\n" +
	"\tcontainer\x18\x04 \x01(\fR\tcontainer\x12)\n" +
	"\x10requested_height\x18\x06 \x01(\x04R\x0frequestedHeightJ\x04\b\x05\x10\x06\"\xb5\x01\n" +
	"\tPullQuery\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12!\n" +
	"\fcontainer_id\x18\x04 \x01(\fR\vcontainerId\x12)\n" +
	"\x10requested_height\x18\x06 \x01(\x04R\x0frequestedHeightJ\x04\b\x05\x10\x06\"\xe3\x01\n" +
	"\x05Chits\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12!\n" +
	"\fpreferred_id\x18\x03 \x01(\fR\vpreferredId\x12\x1f\n" +
	"\vaccepted_id\x18\x04 \x01(\fR\n" +
	"acceptedId\x123\n" +
	"\x16preferred_id_at_height\x18\x05 \x01(\fR\x13preferredIdAtHeight\x12'\n" +
	"\x0faccepted_height\x18\x06 \x01(\x04R\x0eacceptedHeight\"\x7f\n" +
	"\n" +
	"AppRequest\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1a\n" +
	"\bdeadline\x18\x03 \x01(\x04R\bdeadline\x12\x1b\n" +
	"\tapp_bytes\x18\x04 \x01(\fR\bappBytes\"d\n" +
	"\vAppResponse\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1b\n" +
	"\tapp_bytes\x18\x03 \x01(\fR\bappBytes\"\x88\x01\n" +
	"\bAppError\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1d\n" +
	"\n" +
	"request_id\x18\x02 \x01(\rR\trequestId\x12\x1d\n" +
	"\n" +
	"error_code\x18\x03 \x01(\x11R\terrorCode\x12#\n" +
	"\rerror_message\x18\x04 \x01(\tR\ferrorMessage\"C\n" +
	"\tAppGossip\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12\x1b\n" +
	"\tapp_bytes\x18\x02 \x01(\fR\bappBytes\"\xd0\x04\n" +
	"\aSimplex\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\fR\achainId\x12;\n" +
	"\x0eblock_proposal\x18\x02 \x01(\v2\x12.p2p.BlockProposalH\x00R\rblockProposal\x12\x1f\n" +
	"\x04vote\x18\x03 \x01(\v2\t.p2p.VoteH\x00R\x04vote\x12/\n" +
	"\n" +
	"empty_vote\x18\x04 \x01(\v2\x0e.p2p.EmptyVoteH\x00R\temptyVote\x120\n" +
	"\rfinalize_vote\x18\x05 \x01(\v2\t.p2p.VoteH\x00R\ffinalizeVote\x12<\n" +
	"\fnotarization\x18\x06 \x01(\v2\x16.p2p.QuorumCertificateH\x00R\fnotarization\x12G\n" +
	"\x12empty_notarization\x18\a \x01(\v2\x16.p2p.EmptyNotarizationH\x00R\x11emptyNotarization\x12<\n" +
	"\ffinalization\x18\b \x01(\v2\x16.p2p.QuorumCertificateH\x00R\ffinalization\x12J\n" +
	"\x13replication_request\x18\t \x01(\v2\x17.p2p.ReplicationRequestH\x00R\x12replicationRequest\x12M\n" +
	"\x14replication_response\x18\n" +
	" \x01(\v2\x18.p2p.ReplicationResponseH\x00R\x13replicationResponseB\t\n" +
	"\amessage\"D\n" +
	"\rBlockProposal\x12\x14\n" +
	"\x05block\x18\x01 \x01(\fR\x05block\x12\x1d\n" +
	"\x04vote\x18\x02 \x01(\v2\t.p2p.VoteR\x04vote\"~\n" +
	"\x10ProtocolMetadata\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12\x14\n" +
	"\x05epoch\x18\x02 \x01(\x04R\x05epoch\x12\x14\n" +
	"\x05round\x18\x03 \x01(\x04R\x05round\x12\x10\n" +
	"\x03seq\x18\x04 \x01(\x04R\x03seq\x12\x12\n" +
	"\x04prev\x18\x05 \x01(\fR\x04prev\"?\n" +
	"\x11EmptyVoteMetadata\x12\x14\n" +
	"\x05epoch\x18\x01 \x01(\x04R\x05epoch\x12\x14\n" +
	"\x05round\x18\x02 \x01(\x04R\x05round\"X\n" +
	"\vBlockHeader\x121\n" +
	"\bmetadata\x18\x01 \x01(\v2\x15.p2p.ProtocolMetadataR\bmetadata\x12\x16\n" +
	"\x06digest\x18\x02 \x01(\fR\x06digest\"9\n" +
	"\tSignature\x12\x16\n" +
	"\x06signer\x18\x01 \x01(\fR\x06signer\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"i\n" +
	"\x04Vote\x123\n" +
	"\fblock_header\x18\x01 \x01(\v2\x10.p2p.BlockHeaderR\vblockHeader\x12,\n" +
	"\tsignature\x18\x02 \x01(\v2\x0e.p2p.SignatureR\tsignature\"m\n" +
	"\tEmptyVote\x122\n" +
	"\bmetadata\x18\x01 \x01(\v2\x16.p2p.EmptyVoteMetadataR\bmetadata\x12,\n" +
	"\tsignature\x18\x02 \x01(\v2\x0e.p2p.SignatureR\tsignature\"w\n" +
	"\x11QuorumCertificate\x123\n" +
	"\fblock_header\x18\x01 \x01(\v2\x10.p2p.BlockHeaderR\vblockHeader\x12-\n" +
	"\x12quorum_certificate\x18\x02 \x01(\fR\x11quorumCertificate\"v\n" +
	"\x11EmptyNotarization\x122\n" +
	"\bmetadata\x18\x01 \x01(\v2\x16.p2p.EmptyVoteMetadataR\bmetadata\x12-\n" +
	"\x12quorum_certificate\x18\x02 \x01(\fR\x11quorumCertificate\"K\n" +
	"\x12ReplicationRequest\x12\x12\n" +
	"\x04seqs\x18\x01 \x03(\x04R\x04seqs\x12!\n" +
	"\flatest_round\x18\x02 \x01(\x04R\vlatestRound\"p\n" +
	"\x13ReplicationResponse\x12$\n" +
	"\x04data\x18\x01 \x03(\v2\x10.p2p.QuorumRoundR\x04data\x123\n" +
	"\flatest_round\x18\x02 \x01(\v2\x10.p2p.QuorumRoundR\vlatestRound\"\xe2\x01\n" +
	"\vQuorumRound\x12\x14\n" +
	"\x05block\x18\x01 \x01(\fR\x05block\x12:\n" +
	"\fnotarization\x18\x02 \x01(\v2\x16.p2p.QuorumCertificateR\fnotarization\x12E\n" +
	"\x12empty_notarization\x18\x03 \x01(\v2\x16.p2p.EmptyNotarizationR\x11emptyNotarization\x12:\n" +
	"\ffinalization\x18\x04 \x01(\v2\x16.p2p.QuorumCertificateR\ffinalization*U\n" +
	"\n" +
	"EngineType\x12\x1b\n" +
	"\x17ENGINE_TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fENGINE_TYPE_DAG\x10\x01\x12\x15\n" +
	"\x11ENGINE_TYPE_CHAIN\x10\x02B.Z,github.com/ava-labs/avalanchego/proto/pb/p2pb\x06proto3"

var (
	file_p2p_p2p_proto_rawDescOnce sync.Once
	file_p2p_p2p_proto_rawDescData []byte
)

func file_p2p_p2p_proto_rawDescGZIP() []byte {
	file_p2p_p2p_proto_rawDescOnce.Do(func() {
		file_p2p_p2p_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_p2p_p2p_proto_rawDesc), len(file_p2p_p2p_proto_rawDesc)))
	})
	return file_p2p_p2p_proto_rawDescData
}

var file_p2p_p2p_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_p2p_p2p_proto_msgTypes = make([]protoimpl.MessageInfo, 41)
var file_p2p_p2p_proto_goTypes = []any{
	(EngineType)(0),                 // 0: p2p.EngineType
	(*Message)(nil),                 // 1: p2p.Message
	(*Ping)(nil),                    // 2: p2p.Ping
	(*Pong)(nil),                    // 3: p2p.Pong
	(*Handshake)(nil),               // 4: p2p.Handshake
	(*Client)(nil),                  // 5: p2p.Client
	(*BloomFilter)(nil),             // 6: p2p.BloomFilter
	(*ClaimedIpPort)(nil),           // 7: p2p.ClaimedIpPort
	(*GetPeerList)(nil),             // 8: p2p.GetPeerList
	(*PeerList)(nil),                // 9: p2p.PeerList
	(*GetStateSummaryFrontier)(nil), // 10: p2p.GetStateSummaryFrontier
	(*StateSummaryFrontier)(nil),    // 11: p2p.StateSummaryFrontier
	(*GetAcceptedStateSummary)(nil), // 12: p2p.GetAcceptedStateSummary
	(*AcceptedStateSummary)(nil),    // 13: p2p.AcceptedStateSummary
	(*GetAcceptedFrontier)(nil),     // 14: p2p.GetAcceptedFrontier
	(*AcceptedFrontier)(nil),        // 15: p2p.AcceptedFrontier
	(*GetAccepted)(nil),             // 16: p2p.GetAccepted
	(*Accepted)(nil),                // 17: p2p.Accepted
	(*GetAncestors)(nil),            // 18: p2p.GetAncestors
	(*Ancestors)(nil),               // 19: p2p.Ancestors
	(*Get)(nil),                     // 20: p2p.Get
	(*Put)(nil),                     // 21: p2p.Put
	(*PushQuery)(nil),               // 22: p2p.PushQuery
	(*PullQuery)(nil),               // 23: p2p.PullQuery
	(*Chits)(nil),                   // 24: p2p.Chits
	(*AppRequest)(nil),              // 25: p2p.AppRequest
	(*AppResponse)(nil),             // 26: p2p.AppResponse
	(*AppError)(nil),                // 27: p2p.AppError
	(*AppGossip)(nil),               // 28: p2p.AppGossip
	(*Simplex)(nil),                 // 29: p2p.Simplex
	(*BlockProposal)(nil),           // 30: p2p.BlockProposal
	(*ProtocolMetadata)(nil),        // 31: p2p.ProtocolMetadata
	(*EmptyVoteMetadata)(nil),       // 32: p2p.EmptyVoteMetadata
	(*BlockHeader)(nil),             // 33: p2p.BlockHeader
	(*Signature)(nil),               // 34: p2p.Signature
	(*Vote)(nil),                    // 35: p2p.Vote
	(*EmptyVote)(nil),               // 36: p2p.EmptyVote
	(*QuorumCertificate)(nil),       // 37: p2p.QuorumCertificate
	(*EmptyNotarization)(nil),       // 38: p2p.EmptyNotarization
	(*ReplicationRequest)(nil),      // 39: p2p.ReplicationRequest
	(*ReplicationResponse)(nil),     // 40: p2p.ReplicationResponse
	(*QuorumRound)(nil),             // 41: p2p.QuorumRound
}
var file_p2p_p2p_proto_depIdxs = []int32{
	2,  // 0: p2p.Message.ping:type_name -> p2p.Ping
	3,  // 1: p2p.Message.pong:type_name -> p2p.Pong
	4,  // 2: p2p.Message.handshake:type_name -> p2p.Handshake
	8,  // 3: p2p.Message.get_peer_list:type_name -> p2p.GetPeerList
	9,  // 4: p2p.Message.peer_list:type_name -> p2p.PeerList
	10, // 5: p2p.Message.get_state_summary_frontier:type_name -> p2p.GetStateSummaryFrontier
	11, // 6: p2p.Message.state_summary_frontier:type_name -> p2p.StateSummaryFrontier
	12, // 7: p2p.Message.get_accepted_state_summary:type_name -> p2p.GetAcceptedStateSummary
	13, // 8: p2p.Message.accepted_state_summary:type_name -> p2p.AcceptedStateSummary
	14, // 9: p2p.Message.get_accepted_frontier:type_name -> p2p.GetAcceptedFrontier
	15, // 10: p2p.Message.accepted_frontier:type_name -> p2p.AcceptedFrontier
	16, // 11: p2p.Message.get_accepted:type_name -> p2p.GetAccepted
	17, // 12: p2p.Message.accepted:type_name -> p2p.Accepted
	18, // 13: p2p.Message.get_ancestors:type_name -> p2p.GetAncestors
	19, // 14: p2p.Message.ancestors:type_name -> p2p.Ancestors
	20, // 15: p2p.Message.get:type_name -> p2p.Get
	21, // 16: p2p.Message.put:type_name -> p2p.Put
	22, // 17: p2p.Message.push_query:type_name -> p2p.PushQuery
	23, // 18: p2p.Message.pull_query:type_name -> p2p.PullQuery
	24, // 19: p2p.Message.chits:type_name -> p2p.Chits
	25, // 20: p2p.Message.app_request:type_name -> p2p.AppRequest
	26, // 21: p2p.Message.app_response:type_name -> p2p.AppResponse
	28, // 22: p2p.Message.app_gossip:type_name -> p2p.AppGossip
	27, // 23: p2p.Message.app_error:type_name -> p2p.AppError
	29, // 24: p2p.Message.simplex:type_name -> p2p.Simplex
	5,  // 25: p2p.Handshake.client:type_name -> p2p.Client
	6,  // 26: p2p.Handshake.known_peers:type_name -> p2p.BloomFilter
	6,  // 27: p2p.GetPeerList.known_peers:type_name -> p2p.BloomFilter
	7,  // 28: p2p.PeerList.claimed_ip_ports:type_name -> p2p.ClaimedIpPort
	0,  // 29: p2p.GetAncestors.engine_type:type_name -> p2p.EngineType
	30, // 30: p2p.Simplex.block_proposal:type_name -> p2p.BlockProposal
	35, // 31: p2p.Simplex.vote:type_name -> p2p.Vote
	36, // 32: p2p.Simplex.empty_vote:type_name -> p2p.EmptyVote
	35, // 33: p2p.Simplex.finalize_vote:type_name -> p2p.Vote
	37, // 34: p2p.Simplex.notarization:type_name -> p2p.QuorumCertificate
	38, // 35: p2p.Simplex.empty_notarization:type_name -> p2p.EmptyNotarization
	37, // 36: p2p.Simplex.finalization:type_name -> p2p.QuorumCertificate
	39, // 37: p2p.Simplex.replication_request:type_name -> p2p.ReplicationRequest
	40, // 38: p2p.Simplex.replication_response:type_name -> p2p.ReplicationResponse
	35, // 39: p2p.BlockProposal.vote:type_name -> p2p.Vote
	31, // 40: p2p.BlockHeader.metadata:type_name -> p2p.ProtocolMetadata
	33, // 41: p2p.Vote.block_header:type_name -> p2p.BlockHeader
	34, // 42: p2p.Vote.signature:type_name -> p2p.Signature
	32, // 43: p2p.EmptyVote.metadata:type_name -> p2p.EmptyVoteMetadata
	34, // 44: p2p.EmptyVote.signature:type_name -> p2p.Signature
	33, // 45: p2p.QuorumCertificate.block_header:type_name -> p2p.BlockHeader
	32, // 46: p2p.EmptyNotarization.metadata:type_name -> p2p.EmptyVoteMetadata
	41, // 47: p2p.ReplicationResponse.data:type_name -> p2p.QuorumRound
	41, // 48: p2p.ReplicationResponse.latest_round:type_name -> p2p.QuorumRound
	37, // 49: p2p.QuorumRound.notarization:type_name -> p2p.QuorumCertificate
	38, // 50: p2p.QuorumRound.empty_notarization:type_name -> p2p.EmptyNotarization
	37, // 51: p2p.QuorumRound.finalization:type_name -> p2p.QuorumCertificate
	52, // [52:52] is the sub-list for method output_type
	52, // [52:52] is the sub-list for method input_type
	52, // [52:52] is the sub-list for extension type_name
	52, // [52:52] is the sub-list for extension extendee
	0,  // [0:52] is the sub-list for field type_name
}

func init() { file_p2p_p2p_proto_init() }
func file_p2p_p2p_proto_init() {
	if File_p2p_p2p_proto != nil {
		return
	}
	file_p2p_p2p_proto_msgTypes[0].OneofWrappers = []any{
		(*Message_CompressedZstd)(nil),
		(*Message_Ping)(nil),
		(*Message_Pong)(nil),
		(*Message_Handshake)(nil),
		(*Message_GetPeerList)(nil),
		(*Message_PeerList_)(nil),
		(*Message_GetStateSummaryFrontier)(nil),
		(*Message_StateSummaryFrontier_)(nil),
		(*Message_GetAcceptedStateSummary)(nil),
		(*Message_AcceptedStateSummary_)(nil),
		(*Message_GetAcceptedFrontier)(nil),
		(*Message_AcceptedFrontier_)(nil),
		(*Message_GetAccepted)(nil),
		(*Message_Accepted_)(nil),
		(*Message_GetAncestors)(nil),
		(*Message_Ancestors_)(nil),
		(*Message_Get)(nil),
		(*Message_Put)(nil),
		(*Message_PushQuery)(nil),
		(*Message_PullQuery)(nil),
		(*Message_Chits)(nil),
		(*Message_AppRequest)(nil),
		(*Message_AppResponse)(nil),
		(*Message_AppGossip)(nil),
		(*Message_AppError)(nil),
		(*Message_Simplex)(nil),
	}
	file_p2p_p2p_proto_msgTypes[28].OneofWrappers = []any{
		(*Simplex_BlockProposal)(nil),
		(*Simplex_Vote)(nil),
		(*Simplex_EmptyVote)(nil),
		(*Simplex_FinalizeVote)(nil),
		(*Simplex_Notarization)(nil),
		(*Simplex_EmptyNotarization)(nil),
		(*Simplex_Finalization)(nil),
		(*Simplex_ReplicationRequest)(nil),
		(*Simplex_ReplicationResponse)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_p2p_p2p_proto_rawDesc), len(file_p2p_p2p_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   41,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_p2p_p2p_proto_goTypes,
		DependencyIndexes: file_p2p_p2p_proto_depIdxs,
		EnumInfos:         file_p2p_p2p_proto_enumTypes,
		MessageInfos:      file_p2p_p2p_proto_msgTypes,
	}.Build()
	File_p2p_p2p_proto = out.File
	file_p2p_p2p_proto_goTypes = nil
	file_p2p_p2p_proto_depIdxs = nil
}
