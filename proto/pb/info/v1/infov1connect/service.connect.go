// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// Code generated by protoc-gen-connect. DO NOT EDIT.
//
// Source: info/v1/service.proto

package infov1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/ava-labs/avalanchego/proto/pb/info/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// InfoServiceName is the fully-qualified name of the InfoService service.
	InfoServiceName = "info.v1.InfoService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// InfoServiceGetNodeVersionProcedure is the fully-qualified name of the InfoService's
	// GetNodeVersion RPC.
	InfoServiceGetNodeVersionProcedure = "/info.v1.InfoService/GetNodeVersion"
	// InfoServiceGetNodeIDProcedure is the fully-qualified name of the InfoService's GetNodeID RPC.
	InfoServiceGetNodeIDProcedure = "/info.v1.InfoService/GetNodeID"
	// InfoServiceGetNodeIPProcedure is the fully-qualified name of the InfoService's GetNodeIP RPC.
	InfoServiceGetNodeIPProcedure = "/info.v1.InfoService/GetNodeIP"
	// InfoServiceGetNetworkIDProcedure is the fully-qualified name of the InfoService's GetNetworkID
	// RPC.
	InfoServiceGetNetworkIDProcedure = "/info.v1.InfoService/GetNetworkID"
	// InfoServiceGetNetworkNameProcedure is the fully-qualified name of the InfoService's
	// GetNetworkName RPC.
	InfoServiceGetNetworkNameProcedure = "/info.v1.InfoService/GetNetworkName"
	// InfoServiceGetBlockchainIDProcedure is the fully-qualified name of the InfoService's
	// GetBlockchainID RPC.
	InfoServiceGetBlockchainIDProcedure = "/info.v1.InfoService/GetBlockchainID"
	// InfoServicePeersProcedure is the fully-qualified name of the InfoService's Peers RPC.
	InfoServicePeersProcedure = "/info.v1.InfoService/Peers"
	// InfoServiceIsBootstrappedProcedure is the fully-qualified name of the InfoService's
	// IsBootstrapped RPC.
	InfoServiceIsBootstrappedProcedure = "/info.v1.InfoService/IsBootstrapped"
	// InfoServiceUpgradesProcedure is the fully-qualified name of the InfoService's Upgrades RPC.
	InfoServiceUpgradesProcedure = "/info.v1.InfoService/Upgrades"
	// InfoServiceUptimeProcedure is the fully-qualified name of the InfoService's Uptime RPC.
	InfoServiceUptimeProcedure = "/info.v1.InfoService/Uptime"
	// InfoServiceGetVMsProcedure is the fully-qualified name of the InfoService's GetVMs RPC.
	InfoServiceGetVMsProcedure = "/info.v1.InfoService/GetVMs"
)

// InfoServiceClient is a client for the info.v1.InfoService service.
type InfoServiceClient interface {
	GetNodeVersion(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeVersionReply], error)
	GetNodeID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIDReply], error)
	GetNodeIP(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIPReply], error)
	GetNetworkID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkIDReply], error)
	GetNetworkName(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkNameReply], error)
	GetBlockchainID(context.Context, *connect.Request[v1.GetBlockchainIDArgs]) (*connect.Response[v1.GetBlockchainIDReply], error)
	Peers(context.Context, *connect.Request[v1.PeersArgs]) (*connect.Response[v1.PeersReply], error)
	IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedArgs]) (*connect.Response[v1.IsBootstrappedResponse], error)
	Upgrades(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UpgradesReply], error)
	Uptime(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UptimeResponse], error)
	GetVMs(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetVMsReply], error)
}

// NewInfoServiceClient constructs a client for the info.v1.InfoService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewInfoServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) InfoServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	infoServiceMethods := v1.File_info_v1_service_proto.Services().ByName("InfoService").Methods()
	return &infoServiceClient{
		getNodeVersion: connect.NewClient[emptypb.Empty, v1.GetNodeVersionReply](
			httpClient,
			baseURL+InfoServiceGetNodeVersionProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetNodeVersion")),
			connect.WithClientOptions(opts...),
		),
		getNodeID: connect.NewClient[emptypb.Empty, v1.GetNodeIDReply](
			httpClient,
			baseURL+InfoServiceGetNodeIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetNodeID")),
			connect.WithClientOptions(opts...),
		),
		getNodeIP: connect.NewClient[emptypb.Empty, v1.GetNodeIPReply](
			httpClient,
			baseURL+InfoServiceGetNodeIPProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetNodeIP")),
			connect.WithClientOptions(opts...),
		),
		getNetworkID: connect.NewClient[emptypb.Empty, v1.GetNetworkIDReply](
			httpClient,
			baseURL+InfoServiceGetNetworkIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetNetworkID")),
			connect.WithClientOptions(opts...),
		),
		getNetworkName: connect.NewClient[emptypb.Empty, v1.GetNetworkNameReply](
			httpClient,
			baseURL+InfoServiceGetNetworkNameProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetNetworkName")),
			connect.WithClientOptions(opts...),
		),
		getBlockchainID: connect.NewClient[v1.GetBlockchainIDArgs, v1.GetBlockchainIDReply](
			httpClient,
			baseURL+InfoServiceGetBlockchainIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetBlockchainID")),
			connect.WithClientOptions(opts...),
		),
		peers: connect.NewClient[v1.PeersArgs, v1.PeersReply](
			httpClient,
			baseURL+InfoServicePeersProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Peers")),
			connect.WithClientOptions(opts...),
		),
		isBootstrapped: connect.NewClient[v1.IsBootstrappedArgs, v1.IsBootstrappedResponse](
			httpClient,
			baseURL+InfoServiceIsBootstrappedProcedure,
			connect.WithSchema(infoServiceMethods.ByName("IsBootstrapped")),
			connect.WithClientOptions(opts...),
		),
		upgrades: connect.NewClient[emptypb.Empty, v1.UpgradesReply](
			httpClient,
			baseURL+InfoServiceUpgradesProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Upgrades")),
			connect.WithClientOptions(opts...),
		),
		uptime: connect.NewClient[emptypb.Empty, v1.UptimeResponse](
			httpClient,
			baseURL+InfoServiceUptimeProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Uptime")),
			connect.WithClientOptions(opts...),
		),
		getVMs: connect.NewClient[emptypb.Empty, v1.GetVMsReply](
			httpClient,
			baseURL+InfoServiceGetVMsProcedure,
			connect.WithSchema(infoServiceMethods.ByName("GetVMs")),
			connect.WithClientOptions(opts...),
		),
	}
}

// infoServiceClient implements InfoServiceClient.
type infoServiceClient struct {
	getNodeVersion  *connect.Client[emptypb.Empty, v1.GetNodeVersionReply]
	getNodeID       *connect.Client[emptypb.Empty, v1.GetNodeIDReply]
	getNodeIP       *connect.Client[emptypb.Empty, v1.GetNodeIPReply]
	getNetworkID    *connect.Client[emptypb.Empty, v1.GetNetworkIDReply]
	getNetworkName  *connect.Client[emptypb.Empty, v1.GetNetworkNameReply]
	getBlockchainID *connect.Client[v1.GetBlockchainIDArgs, v1.GetBlockchainIDReply]
	peers           *connect.Client[v1.PeersArgs, v1.PeersReply]
	isBootstrapped  *connect.Client[v1.IsBootstrappedArgs, v1.IsBootstrappedResponse]
	upgrades        *connect.Client[emptypb.Empty, v1.UpgradesReply]
	uptime          *connect.Client[emptypb.Empty, v1.UptimeResponse]
	getVMs          *connect.Client[emptypb.Empty, v1.GetVMsReply]
}

// GetNodeVersion calls info.v1.InfoService.GetNodeVersion.
func (c *infoServiceClient) GetNodeVersion(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeVersionReply], error) {
	return c.getNodeVersion.CallUnary(ctx, req)
}

// GetNodeID calls info.v1.InfoService.GetNodeID.
func (c *infoServiceClient) GetNodeID(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIDReply], error) {
	return c.getNodeID.CallUnary(ctx, req)
}

// GetNodeIP calls info.v1.InfoService.GetNodeIP.
func (c *infoServiceClient) GetNodeIP(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIPReply], error) {
	return c.getNodeIP.CallUnary(ctx, req)
}

// GetNetworkID calls info.v1.InfoService.GetNetworkID.
func (c *infoServiceClient) GetNetworkID(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkIDReply], error) {
	return c.getNetworkID.CallUnary(ctx, req)
}

// GetNetworkName calls info.v1.InfoService.GetNetworkName.
func (c *infoServiceClient) GetNetworkName(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkNameReply], error) {
	return c.getNetworkName.CallUnary(ctx, req)
}

// GetBlockchainID calls info.v1.InfoService.GetBlockchainID.
func (c *infoServiceClient) GetBlockchainID(ctx context.Context, req *connect.Request[v1.GetBlockchainIDArgs]) (*connect.Response[v1.GetBlockchainIDReply], error) {
	return c.getBlockchainID.CallUnary(ctx, req)
}

// Peers calls info.v1.InfoService.Peers.
func (c *infoServiceClient) Peers(ctx context.Context, req *connect.Request[v1.PeersArgs]) (*connect.Response[v1.PeersReply], error) {
	return c.peers.CallUnary(ctx, req)
}

// IsBootstrapped calls info.v1.InfoService.IsBootstrapped.
func (c *infoServiceClient) IsBootstrapped(ctx context.Context, req *connect.Request[v1.IsBootstrappedArgs]) (*connect.Response[v1.IsBootstrappedResponse], error) {
	return c.isBootstrapped.CallUnary(ctx, req)
}

// Upgrades calls info.v1.InfoService.Upgrades.
func (c *infoServiceClient) Upgrades(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.UpgradesReply], error) {
	return c.upgrades.CallUnary(ctx, req)
}

// Uptime calls info.v1.InfoService.Uptime.
func (c *infoServiceClient) Uptime(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.UptimeResponse], error) {
	return c.uptime.CallUnary(ctx, req)
}

// GetVMs calls info.v1.InfoService.GetVMs.
func (c *infoServiceClient) GetVMs(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetVMsReply], error) {
	return c.getVMs.CallUnary(ctx, req)
}

// InfoServiceHandler is an implementation of the info.v1.InfoService service.
type InfoServiceHandler interface {
	GetNodeVersion(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeVersionReply], error)
	GetNodeID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIDReply], error)
	GetNodeIP(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIPReply], error)
	GetNetworkID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkIDReply], error)
	GetNetworkName(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkNameReply], error)
	GetBlockchainID(context.Context, *connect.Request[v1.GetBlockchainIDArgs]) (*connect.Response[v1.GetBlockchainIDReply], error)
	Peers(context.Context, *connect.Request[v1.PeersArgs]) (*connect.Response[v1.PeersReply], error)
	IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedArgs]) (*connect.Response[v1.IsBootstrappedResponse], error)
	Upgrades(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UpgradesReply], error)
	Uptime(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UptimeResponse], error)
	GetVMs(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetVMsReply], error)
}

// NewInfoServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewInfoServiceHandler(svc InfoServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	infoServiceMethods := v1.File_info_v1_service_proto.Services().ByName("InfoService").Methods()
	infoServiceGetNodeVersionHandler := connect.NewUnaryHandler(
		InfoServiceGetNodeVersionProcedure,
		svc.GetNodeVersion,
		connect.WithSchema(infoServiceMethods.ByName("GetNodeVersion")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetNodeIDHandler := connect.NewUnaryHandler(
		InfoServiceGetNodeIDProcedure,
		svc.GetNodeID,
		connect.WithSchema(infoServiceMethods.ByName("GetNodeID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetNodeIPHandler := connect.NewUnaryHandler(
		InfoServiceGetNodeIPProcedure,
		svc.GetNodeIP,
		connect.WithSchema(infoServiceMethods.ByName("GetNodeIP")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetNetworkIDHandler := connect.NewUnaryHandler(
		InfoServiceGetNetworkIDProcedure,
		svc.GetNetworkID,
		connect.WithSchema(infoServiceMethods.ByName("GetNetworkID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetNetworkNameHandler := connect.NewUnaryHandler(
		InfoServiceGetNetworkNameProcedure,
		svc.GetNetworkName,
		connect.WithSchema(infoServiceMethods.ByName("GetNetworkName")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetBlockchainIDHandler := connect.NewUnaryHandler(
		InfoServiceGetBlockchainIDProcedure,
		svc.GetBlockchainID,
		connect.WithSchema(infoServiceMethods.ByName("GetBlockchainID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServicePeersHandler := connect.NewUnaryHandler(
		InfoServicePeersProcedure,
		svc.Peers,
		connect.WithSchema(infoServiceMethods.ByName("Peers")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceIsBootstrappedHandler := connect.NewUnaryHandler(
		InfoServiceIsBootstrappedProcedure,
		svc.IsBootstrapped,
		connect.WithSchema(infoServiceMethods.ByName("IsBootstrapped")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceUpgradesHandler := connect.NewUnaryHandler(
		InfoServiceUpgradesProcedure,
		svc.Upgrades,
		connect.WithSchema(infoServiceMethods.ByName("Upgrades")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceUptimeHandler := connect.NewUnaryHandler(
		InfoServiceUptimeProcedure,
		svc.Uptime,
		connect.WithSchema(infoServiceMethods.ByName("Uptime")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceGetVMsHandler := connect.NewUnaryHandler(
		InfoServiceGetVMsProcedure,
		svc.GetVMs,
		connect.WithSchema(infoServiceMethods.ByName("GetVMs")),
		connect.WithHandlerOptions(opts...),
	)
	return "/info.v1.InfoService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case InfoServiceGetNodeVersionProcedure:
			infoServiceGetNodeVersionHandler.ServeHTTP(w, r)
		case InfoServiceGetNodeIDProcedure:
			infoServiceGetNodeIDHandler.ServeHTTP(w, r)
		case InfoServiceGetNodeIPProcedure:
			infoServiceGetNodeIPHandler.ServeHTTP(w, r)
		case InfoServiceGetNetworkIDProcedure:
			infoServiceGetNetworkIDHandler.ServeHTTP(w, r)
		case InfoServiceGetNetworkNameProcedure:
			infoServiceGetNetworkNameHandler.ServeHTTP(w, r)
		case InfoServiceGetBlockchainIDProcedure:
			infoServiceGetBlockchainIDHandler.ServeHTTP(w, r)
		case InfoServicePeersProcedure:
			infoServicePeersHandler.ServeHTTP(w, r)
		case InfoServiceIsBootstrappedProcedure:
			infoServiceIsBootstrappedHandler.ServeHTTP(w, r)
		case InfoServiceUpgradesProcedure:
			infoServiceUpgradesHandler.ServeHTTP(w, r)
		case InfoServiceUptimeProcedure:
			infoServiceUptimeHandler.ServeHTTP(w, r)
		case InfoServiceGetVMsProcedure:
			infoServiceGetVMsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedInfoServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedInfoServiceHandler struct{}

func (UnimplementedInfoServiceHandler) GetNodeVersion(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeVersionReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetNodeVersion is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetNodeID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIDReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetNodeID is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetNodeIP(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNodeIPReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetNodeIP is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetNetworkID(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkIDReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetNetworkID is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetNetworkName(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetNetworkNameReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetNetworkName is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetBlockchainID(context.Context, *connect.Request[v1.GetBlockchainIDArgs]) (*connect.Response[v1.GetBlockchainIDReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetBlockchainID is not implemented"))
}

func (UnimplementedInfoServiceHandler) Peers(context.Context, *connect.Request[v1.PeersArgs]) (*connect.Response[v1.PeersReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Peers is not implemented"))
}

func (UnimplementedInfoServiceHandler) IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedArgs]) (*connect.Response[v1.IsBootstrappedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.IsBootstrapped is not implemented"))
}

func (UnimplementedInfoServiceHandler) Upgrades(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UpgradesReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Upgrades is not implemented"))
}

func (UnimplementedInfoServiceHandler) Uptime(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.UptimeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Uptime is not implemented"))
}

func (UnimplementedInfoServiceHandler) GetVMs(context.Context, *connect.Request[emptypb.Empty]) (*connect.Response[v1.GetVMsReply], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.GetVMs is not implemented"))
}
