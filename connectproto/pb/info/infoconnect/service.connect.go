// Copyright (C) 2019-2024, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: info/v1/service.proto

package infov1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/ava-labs/avalanchego/proto/pb/info/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// InfoServiceName is the fully-qualified name of the InfoService service.
	InfoServiceName = "info.v1.InfoService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// InfoServiceNodeVersionProcedure is the fully-qualified name of the InfoService's NodeVersion RPC.
	InfoServiceNodeVersionProcedure = "/info.v1.InfoService/NodeVersion"
	// InfoServiceNodeIDProcedure is the fully-qualified name of the InfoService's NodeID RPC.
	InfoServiceNodeIDProcedure = "/info.v1.InfoService/NodeID"
	// InfoServiceNodeIPProcedure is the fully-qualified name of the InfoService's NodeIP RPC.
	InfoServiceNodeIPProcedure = "/info.v1.InfoService/NodeIP"
	// InfoServiceNetworkIDProcedure is the fully-qualified name of the InfoService's NetworkID RPC.
	InfoServiceNetworkIDProcedure = "/info.v1.InfoService/NetworkID"
	// InfoServiceNetworkNameProcedure is the fully-qualified name of the InfoService's NetworkName RPC.
	InfoServiceNetworkNameProcedure = "/info.v1.InfoService/NetworkName"
	// InfoServiceBlockchainIDProcedure is the fully-qualified name of the InfoService's BlockchainID
	// RPC.
	InfoServiceBlockchainIDProcedure = "/info.v1.InfoService/BlockchainID"
	// InfoServicePeersProcedure is the fully-qualified name of the InfoService's Peers RPC.
	InfoServicePeersProcedure = "/info.v1.InfoService/Peers"
	// InfoServiceIsBootstrappedProcedure is the fully-qualified name of the InfoService's
	// IsBootstrapped RPC.
	InfoServiceIsBootstrappedProcedure = "/info.v1.InfoService/IsBootstrapped"
	// InfoServiceUpgradesProcedure is the fully-qualified name of the InfoService's Upgrades RPC.
	InfoServiceUpgradesProcedure = "/info.v1.InfoService/Upgrades"
	// InfoServiceUptimeProcedure is the fully-qualified name of the InfoService's Uptime RPC.
	InfoServiceUptimeProcedure = "/info.v1.InfoService/Uptime"
	// InfoServiceVMsProcedure is the fully-qualified name of the InfoService's VMs RPC.
	InfoServiceVMsProcedure = "/info.v1.InfoService/VMs"
)

// InfoServiceClient is a client for the info.v1.InfoService service.
type InfoServiceClient interface {
	NodeVersion(context.Context, *connect.Request[v1.NodeVersionRequest]) (*connect.Response[v1.NodeVersionResponse], error)
	NodeID(context.Context, *connect.Request[v1.NodeIDRequest]) (*connect.Response[v1.NodeIDResponse], error)
	NodeIP(context.Context, *connect.Request[v1.NodeIPRequest]) (*connect.Response[v1.NodeIPResponse], error)
	NetworkID(context.Context, *connect.Request[v1.NetworkIDRequest]) (*connect.Response[v1.NetworkIDResponse], error)
	NetworkName(context.Context, *connect.Request[v1.NetworkNameRequest]) (*connect.Response[v1.NetworkNameResponse], error)
	BlockchainID(context.Context, *connect.Request[v1.BlockchainIDRequest]) (*connect.Response[v1.BlockchainIDResponse], error)
	Peers(context.Context, *connect.Request[v1.PeersRequest]) (*connect.Response[v1.PeersResponse], error)
	IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedRequest]) (*connect.Response[v1.IsBootstrappedResponse], error)
	Upgrades(context.Context, *connect.Request[v1.UpgradesRequest]) (*connect.Response[v1.UpgradesResponse], error)
	Uptime(context.Context, *connect.Request[v1.UptimeRequest]) (*connect.Response[v1.UptimeResponse], error)
	VMs(context.Context, *connect.Request[v1.VMsRequest]) (*connect.Response[v1.VMsResponse], error)
}

// NewInfoServiceClient constructs a client for the info.v1.InfoService service. By default, it uses
// the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewInfoServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) InfoServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	infoServiceMethods := v1.File_info_v1_service_proto.Services().ByName("InfoService").Methods()
	return &infoServiceClient{
		nodeVersion: connect.NewClient[v1.NodeVersionRequest, v1.NodeVersionResponse](
			httpClient,
			baseURL+InfoServiceNodeVersionProcedure,
			connect.WithSchema(infoServiceMethods.ByName("NodeVersion")),
			connect.WithClientOptions(opts...),
		),
		nodeID: connect.NewClient[v1.NodeIDRequest, v1.NodeIDResponse](
			httpClient,
			baseURL+InfoServiceNodeIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("NodeID")),
			connect.WithClientOptions(opts...),
		),
		nodeIP: connect.NewClient[v1.NodeIPRequest, v1.NodeIPResponse](
			httpClient,
			baseURL+InfoServiceNodeIPProcedure,
			connect.WithSchema(infoServiceMethods.ByName("NodeIP")),
			connect.WithClientOptions(opts...),
		),
		networkID: connect.NewClient[v1.NetworkIDRequest, v1.NetworkIDResponse](
			httpClient,
			baseURL+InfoServiceNetworkIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("NetworkID")),
			connect.WithClientOptions(opts...),
		),
		networkName: connect.NewClient[v1.NetworkNameRequest, v1.NetworkNameResponse](
			httpClient,
			baseURL+InfoServiceNetworkNameProcedure,
			connect.WithSchema(infoServiceMethods.ByName("NetworkName")),
			connect.WithClientOptions(opts...),
		),
		blockchainID: connect.NewClient[v1.BlockchainIDRequest, v1.BlockchainIDResponse](
			httpClient,
			baseURL+InfoServiceBlockchainIDProcedure,
			connect.WithSchema(infoServiceMethods.ByName("BlockchainID")),
			connect.WithClientOptions(opts...),
		),
		peers: connect.NewClient[v1.PeersRequest, v1.PeersResponse](
			httpClient,
			baseURL+InfoServicePeersProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Peers")),
			connect.WithClientOptions(opts...),
		),
		isBootstrapped: connect.NewClient[v1.IsBootstrappedRequest, v1.IsBootstrappedResponse](
			httpClient,
			baseURL+InfoServiceIsBootstrappedProcedure,
			connect.WithSchema(infoServiceMethods.ByName("IsBootstrapped")),
			connect.WithClientOptions(opts...),
		),
		upgrades: connect.NewClient[v1.UpgradesRequest, v1.UpgradesResponse](
			httpClient,
			baseURL+InfoServiceUpgradesProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Upgrades")),
			connect.WithClientOptions(opts...),
		),
		uptime: connect.NewClient[v1.UptimeRequest, v1.UptimeResponse](
			httpClient,
			baseURL+InfoServiceUptimeProcedure,
			connect.WithSchema(infoServiceMethods.ByName("Uptime")),
			connect.WithClientOptions(opts...),
		),
		vMs: connect.NewClient[v1.VMsRequest, v1.VMsResponse](
			httpClient,
			baseURL+InfoServiceVMsProcedure,
			connect.WithSchema(infoServiceMethods.ByName("VMs")),
			connect.WithClientOptions(opts...),
		),
	}
}

// infoServiceClient implements InfoServiceClient.
type infoServiceClient struct {
	nodeVersion    *connect.Client[v1.NodeVersionRequest, v1.NodeVersionResponse]
	nodeID         *connect.Client[v1.NodeIDRequest, v1.NodeIDResponse]
	nodeIP         *connect.Client[v1.NodeIPRequest, v1.NodeIPResponse]
	networkID      *connect.Client[v1.NetworkIDRequest, v1.NetworkIDResponse]
	networkName    *connect.Client[v1.NetworkNameRequest, v1.NetworkNameResponse]
	blockchainID   *connect.Client[v1.BlockchainIDRequest, v1.BlockchainIDResponse]
	peers          *connect.Client[v1.PeersRequest, v1.PeersResponse]
	isBootstrapped *connect.Client[v1.IsBootstrappedRequest, v1.IsBootstrappedResponse]
	upgrades       *connect.Client[v1.UpgradesRequest, v1.UpgradesResponse]
	uptime         *connect.Client[v1.UptimeRequest, v1.UptimeResponse]
	vMs            *connect.Client[v1.VMsRequest, v1.VMsResponse]
}

// NodeVersion calls info.v1.InfoService.NodeVersion.
func (c *infoServiceClient) NodeVersion(ctx context.Context, req *connect.Request[v1.NodeVersionRequest]) (*connect.Response[v1.NodeVersionResponse], error) {
	return c.nodeVersion.CallUnary(ctx, req)
}

// NodeID calls info.v1.InfoService.NodeID.
func (c *infoServiceClient) NodeID(ctx context.Context, req *connect.Request[v1.NodeIDRequest]) (*connect.Response[v1.NodeIDResponse], error) {
	return c.nodeID.CallUnary(ctx, req)
}

// NodeIP calls info.v1.InfoService.NodeIP.
func (c *infoServiceClient) NodeIP(ctx context.Context, req *connect.Request[v1.NodeIPRequest]) (*connect.Response[v1.NodeIPResponse], error) {
	return c.nodeIP.CallUnary(ctx, req)
}

// NetworkID calls info.v1.InfoService.NetworkID.
func (c *infoServiceClient) NetworkID(ctx context.Context, req *connect.Request[v1.NetworkIDRequest]) (*connect.Response[v1.NetworkIDResponse], error) {
	return c.networkID.CallUnary(ctx, req)
}

// NetworkName calls info.v1.InfoService.NetworkName.
func (c *infoServiceClient) NetworkName(ctx context.Context, req *connect.Request[v1.NetworkNameRequest]) (*connect.Response[v1.NetworkNameResponse], error) {
	return c.networkName.CallUnary(ctx, req)
}

// BlockchainID calls info.v1.InfoService.BlockchainID.
func (c *infoServiceClient) BlockchainID(ctx context.Context, req *connect.Request[v1.BlockchainIDRequest]) (*connect.Response[v1.BlockchainIDResponse], error) {
	return c.blockchainID.CallUnary(ctx, req)
}

// Peers calls info.v1.InfoService.Peers.
func (c *infoServiceClient) Peers(ctx context.Context, req *connect.Request[v1.PeersRequest]) (*connect.Response[v1.PeersResponse], error) {
	return c.peers.CallUnary(ctx, req)
}

// IsBootstrapped calls info.v1.InfoService.IsBootstrapped.
func (c *infoServiceClient) IsBootstrapped(ctx context.Context, req *connect.Request[v1.IsBootstrappedRequest]) (*connect.Response[v1.IsBootstrappedResponse], error) {
	return c.isBootstrapped.CallUnary(ctx, req)
}

// Upgrades calls info.v1.InfoService.Upgrades.
func (c *infoServiceClient) Upgrades(ctx context.Context, req *connect.Request[v1.UpgradesRequest]) (*connect.Response[v1.UpgradesResponse], error) {
	return c.upgrades.CallUnary(ctx, req)
}

// Uptime calls info.v1.InfoService.Uptime.
func (c *infoServiceClient) Uptime(ctx context.Context, req *connect.Request[v1.UptimeRequest]) (*connect.Response[v1.UptimeResponse], error) {
	return c.uptime.CallUnary(ctx, req)
}

// VMs calls info.v1.InfoService.VMs.
func (c *infoServiceClient) VMs(ctx context.Context, req *connect.Request[v1.VMsRequest]) (*connect.Response[v1.VMsResponse], error) {
	return c.vMs.CallUnary(ctx, req)
}

// InfoServiceHandler is an implementation of the info.v1.InfoService service.
type InfoServiceHandler interface {
	NodeVersion(context.Context, *connect.Request[v1.NodeVersionRequest]) (*connect.Response[v1.NodeVersionResponse], error)
	NodeID(context.Context, *connect.Request[v1.NodeIDRequest]) (*connect.Response[v1.NodeIDResponse], error)
	NodeIP(context.Context, *connect.Request[v1.NodeIPRequest]) (*connect.Response[v1.NodeIPResponse], error)
	NetworkID(context.Context, *connect.Request[v1.NetworkIDRequest]) (*connect.Response[v1.NetworkIDResponse], error)
	NetworkName(context.Context, *connect.Request[v1.NetworkNameRequest]) (*connect.Response[v1.NetworkNameResponse], error)
	BlockchainID(context.Context, *connect.Request[v1.BlockchainIDRequest]) (*connect.Response[v1.BlockchainIDResponse], error)
	Peers(context.Context, *connect.Request[v1.PeersRequest]) (*connect.Response[v1.PeersResponse], error)
	IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedRequest]) (*connect.Response[v1.IsBootstrappedResponse], error)
	Upgrades(context.Context, *connect.Request[v1.UpgradesRequest]) (*connect.Response[v1.UpgradesResponse], error)
	Uptime(context.Context, *connect.Request[v1.UptimeRequest]) (*connect.Response[v1.UptimeResponse], error)
	VMs(context.Context, *connect.Request[v1.VMsRequest]) (*connect.Response[v1.VMsResponse], error)
}

// NewInfoServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewInfoServiceHandler(svc InfoServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	infoServiceMethods := v1.File_info_v1_service_proto.Services().ByName("InfoService").Methods()
	infoServiceNodeVersionHandler := connect.NewUnaryHandler(
		InfoServiceNodeVersionProcedure,
		svc.NodeVersion,
		connect.WithSchema(infoServiceMethods.ByName("NodeVersion")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceNodeIDHandler := connect.NewUnaryHandler(
		InfoServiceNodeIDProcedure,
		svc.NodeID,
		connect.WithSchema(infoServiceMethods.ByName("NodeID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceNodeIPHandler := connect.NewUnaryHandler(
		InfoServiceNodeIPProcedure,
		svc.NodeIP,
		connect.WithSchema(infoServiceMethods.ByName("NodeIP")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceNetworkIDHandler := connect.NewUnaryHandler(
		InfoServiceNetworkIDProcedure,
		svc.NetworkID,
		connect.WithSchema(infoServiceMethods.ByName("NetworkID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceNetworkNameHandler := connect.NewUnaryHandler(
		InfoServiceNetworkNameProcedure,
		svc.NetworkName,
		connect.WithSchema(infoServiceMethods.ByName("NetworkName")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceBlockchainIDHandler := connect.NewUnaryHandler(
		InfoServiceBlockchainIDProcedure,
		svc.BlockchainID,
		connect.WithSchema(infoServiceMethods.ByName("BlockchainID")),
		connect.WithHandlerOptions(opts...),
	)
	infoServicePeersHandler := connect.NewUnaryHandler(
		InfoServicePeersProcedure,
		svc.Peers,
		connect.WithSchema(infoServiceMethods.ByName("Peers")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceIsBootstrappedHandler := connect.NewUnaryHandler(
		InfoServiceIsBootstrappedProcedure,
		svc.IsBootstrapped,
		connect.WithSchema(infoServiceMethods.ByName("IsBootstrapped")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceUpgradesHandler := connect.NewUnaryHandler(
		InfoServiceUpgradesProcedure,
		svc.Upgrades,
		connect.WithSchema(infoServiceMethods.ByName("Upgrades")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceUptimeHandler := connect.NewUnaryHandler(
		InfoServiceUptimeProcedure,
		svc.Uptime,
		connect.WithSchema(infoServiceMethods.ByName("Uptime")),
		connect.WithHandlerOptions(opts...),
	)
	infoServiceVMsHandler := connect.NewUnaryHandler(
		InfoServiceVMsProcedure,
		svc.VMs,
		connect.WithSchema(infoServiceMethods.ByName("VMs")),
		connect.WithHandlerOptions(opts...),
	)
	return "/info.v1.InfoService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case InfoServiceNodeVersionProcedure:
			infoServiceNodeVersionHandler.ServeHTTP(w, r)
		case InfoServiceNodeIDProcedure:
			infoServiceNodeIDHandler.ServeHTTP(w, r)
		case InfoServiceNodeIPProcedure:
			infoServiceNodeIPHandler.ServeHTTP(w, r)
		case InfoServiceNetworkIDProcedure:
			infoServiceNetworkIDHandler.ServeHTTP(w, r)
		case InfoServiceNetworkNameProcedure:
			infoServiceNetworkNameHandler.ServeHTTP(w, r)
		case InfoServiceBlockchainIDProcedure:
			infoServiceBlockchainIDHandler.ServeHTTP(w, r)
		case InfoServicePeersProcedure:
			infoServicePeersHandler.ServeHTTP(w, r)
		case InfoServiceIsBootstrappedProcedure:
			infoServiceIsBootstrappedHandler.ServeHTTP(w, r)
		case InfoServiceUpgradesProcedure:
			infoServiceUpgradesHandler.ServeHTTP(w, r)
		case InfoServiceUptimeProcedure:
			infoServiceUptimeHandler.ServeHTTP(w, r)
		case InfoServiceVMsProcedure:
			infoServiceVMsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedInfoServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedInfoServiceHandler struct{}

func (UnimplementedInfoServiceHandler) NodeVersion(context.Context, *connect.Request[v1.NodeVersionRequest]) (*connect.Response[v1.NodeVersionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.NodeVersion is not implemented"))
}

func (UnimplementedInfoServiceHandler) NodeID(context.Context, *connect.Request[v1.NodeIDRequest]) (*connect.Response[v1.NodeIDResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.NodeID is not implemented"))
}

func (UnimplementedInfoServiceHandler) NodeIP(context.Context, *connect.Request[v1.NodeIPRequest]) (*connect.Response[v1.NodeIPResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.NodeIP is not implemented"))
}

func (UnimplementedInfoServiceHandler) NetworkID(context.Context, *connect.Request[v1.NetworkIDRequest]) (*connect.Response[v1.NetworkIDResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.NetworkID is not implemented"))
}

func (UnimplementedInfoServiceHandler) NetworkName(context.Context, *connect.Request[v1.NetworkNameRequest]) (*connect.Response[v1.NetworkNameResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.NetworkName is not implemented"))
}

func (UnimplementedInfoServiceHandler) BlockchainID(context.Context, *connect.Request[v1.BlockchainIDRequest]) (*connect.Response[v1.BlockchainIDResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.BlockchainID is not implemented"))
}

func (UnimplementedInfoServiceHandler) Peers(context.Context, *connect.Request[v1.PeersRequest]) (*connect.Response[v1.PeersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Peers is not implemented"))
}

func (UnimplementedInfoServiceHandler) IsBootstrapped(context.Context, *connect.Request[v1.IsBootstrappedRequest]) (*connect.Response[v1.IsBootstrappedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.IsBootstrapped is not implemented"))
}

func (UnimplementedInfoServiceHandler) Upgrades(context.Context, *connect.Request[v1.UpgradesRequest]) (*connect.Response[v1.UpgradesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Upgrades is not implemented"))
}

func (UnimplementedInfoServiceHandler) Uptime(context.Context, *connect.Request[v1.UptimeRequest]) (*connect.Response[v1.UptimeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.Uptime is not implemented"))
}

func (UnimplementedInfoServiceHandler) VMs(context.Context, *connect.Request[v1.VMsRequest]) (*connect.Response[v1.VMsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("info.v1.InfoService.VMs is not implemented"))
}
