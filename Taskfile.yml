# https://taskfile.dev
# To run on a system without task installed, `./scripts/run_task.sh` will execute it with `go run`.
# If in the nix dev shell, `task` is available.

version: '3'

tasks:
  default: ./scripts/run_task.sh --list

  build:
    desc: Builds avalanchego
    cmd: ./scripts/build.sh

  build-antithesis-images-avalanchego:
    desc: Builds docker images for antithesis for the avalanchego test setup
    env:
      TEST_SETUP: avalanchego
    cmd: bash -x ./scripts/build_antithesis_images.sh

  build-antithesis-images-xsvm:
    desc: Builds docker images for antithesis for the xsvm test setup
    env:
      TEST_SETUP: xsvm
    cmd: bash -x ./scripts/build_antithesis_images.sh

  build-bootstrap-monitor:
    desc: Builds bootstrap-monitor
    cmd: ./scripts/build_bootstrap_monitor.sh

  build-bootstrap-monitor-image:
    desc: Builds docker image for bootstrap-monitor
    cmd: ./scripts/build_bootstrap_monitor_image.sh

  build-image:
    desc: Builds docker image for avalanchego
    cmd: ./scripts/build_image.sh

  build-race:
    desc: Builds avalanchego with race detection enabled
    cmd: ./scripts/build.sh -r

  build-tmpnetctl:
    desc: Builds tmpnetctl
    cmd: ./scripts/build_tmpnetctl.sh

  build-xsvm:
    desc: Builds xsvm plugin
    cmd: ./scripts/build_xsvm.sh

  build-xsvm-image:
    desc: Builds xsvm image
    cmd: ./scripts/build_xsvm_image.sh

  check-clean-branch:
    desc: Checks that the git working tree is clean
    cmd: .github/workflows/check-clean-branch.sh

  check-generate-canoto:
    desc: Checks that generated canoto is up-to-date (requires a clean git working tree)
    cmds:
      - task: generate-canoto
      - task: check-clean-branch

  check-generate-load-contract-bindings:
    desc: Checks that generated load contract bindings are up-to-date (requires a clean git working tree)
    cmds:
      - task: generate-load-contract-bindings
      - task: check-clean-branch

  check-generate-mocks:
    desc: Checks that generated mocks are up-to-date (requires a clean git working tree)
    cmds:
      - task: generate-mocks
      - task: check-clean-branch

  check-generate-protobuf:
    desc: Checks that generated protobuf is up-to-date (requires a clean git working tree)
    cmds:
      - task: generate-protobuf
      - task: check-clean-branch

  check-go-mod-tidy:
    desc: Checks that go.mod and go.sum are up-to-date (requires a clean git working tree)
    cmds:
      - cmd: go mod tidy
      - task: check-clean-branch

  generate-mocks:
    desc: Generates testing mocks
    cmds:
      - cmd: grep -lr -E '^// Code generated by MockGen\. DO NOT EDIT\.$' . | xargs -r rm
      - cmd: go generate -run "go.uber.org/mock/mockgen" ./...

  generate-canoto:
    desc: Generates canoto
    cmd: go generate -run "github.com/StephenButtolph/canoto/canoto" ./...

  generate-load-contract-bindings:
    desc: Generates load contract bindings
    cmds:
      - cmd: grep -lr -E '^// Code generated - DO NOT EDIT\.$' tests/load/c | xargs -r rm
      - cmd: go generate ./tests/load/c/...

  generate-protobuf:
    desc: Generates protobuf
    cmd: ./scripts/protobuf_codegen.sh

  ginkgo-build:
    desc: Runs ginkgo against the current working directory
    cmd: ./bin/ginkgo build {{.USER_WORKING_DIR}}

  install-nix:
    desc: Installs nix with the determinate systems installer
    cmd: curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | sh -s -- install

  lint:
    desc: Runs static analysis tests of golang code
    cmd: ./scripts/lint.sh

  lint-action:
    desc: Runs actionlint to check sanity of github action configuration
    cmd: ./scripts/actionlint.sh

  lint-all:
    desc: Runs all lint checks in parallel
    deps:
      - lint
      - lint-action
      - lint-shell

  lint-all-ci:
    desc: Runs all lint checks one-by-one
    cmds:
      - task: lint
      - task: lint-action
      - task: lint-shell

  lint-shell:
    desc: Runs shellcheck to check sanity of shell scripts
    cmd: ./scripts/shellcheck.sh

  test-bootstrap-monitor-e2e:
    desc: Runs bootstrap monitor e2e tests
    cmd: bash -x ./scripts/tests.e2e.bootstrap_monitor.sh

  test-build-antithesis-images-avalanchego:
    desc: Tests the build of antithesis images for the avalanchego test setup
    env:
      TEST_SETUP: avalanchego
    cmds:
      - task: build-race
      - cmd: go run ./tests/antithesis/avalanchego --avalanchego-path=./build/avalanchego --duration=120s
      - cmd: bash -x ./scripts/tests.build_antithesis_images.sh

  test-build-antithesis-images-xsvm:
    desc: Tests the build of antithesis images for the xsvm test setup
    env:
      TEST_SETUP: xsvm
    cmds:
      - task: build-race
      - task: build-xsvm
      - cmd: go run ./tests/antithesis/xsvm --avalanchego-path=./build/avalanchego --duration=120s
      - cmd: bash -x ./scripts/tests.build_antithesis_images.sh

  test-build-image:
    # On mac, docker/podman/lima should work out-of-the-box.
    # On linux, requires qemu (e.g. apt -y install qemu-system qemu-user-static).
    desc: Runs test of cross-platform docker image build
    cmd: bash -x scripts/tests.build_image.sh

  test-e2e:
    desc: Runs e2e tests
    cmds:
      - task: build
      - task: build-xsvm
      - cmd: bash -x ./scripts/tests.e2e.sh {{.CLI_ARGS}}

  test-e2e-ci:
    desc: Runs e2e tests [serially with race detection enabled]
    env:
      E2E_SERIAL: 1
    cmds:
      - task: build-race
      - task: build-xsvm
      - cmd: bash -x ./scripts/tests.e2e.sh {{.CLI_ARGS}}

  test-e2e-existing-ci:
    desc: Runs e2e tests with an existing network [serially with race detection enabled]
    env:
      E2E_SERIAL: 1
    cmds:
      - task: build-race
      - task: build-xsvm
      - cmd: bash -x ./scripts/tests.e2e.existing.sh {{.CLI_ARGS}}

  test-e2e-kube:
    desc: Runs e2e tests against a network deployed to kube
    cmds:
      - cmd: bash -x ./scripts/tests.e2e.kube.sh {{.CLI_ARGS}}

  test-e2e-kube-ci:
    desc: Runs e2e tests against a network deployed to kube [serially]
    env:
      E2E_SERIAL: 1
    cmds:
      - task: test-e2e-kube

  # To use a different fuzz time, run `task test-fuzz FUZZTIME=[value in seconds]`.
  # A value of `-1` will run until it encounters a failing output.

  test-fuzz:
    desc: Runs each fuzz test for 10 seconds
    vars:
      FUZZTIME: '{{.FUZZTIME| default "10"}}'
    cmd: ./scripts/build_fuzz.sh {{.FUZZTIME}}

  test-fuzz-long:
    desc: Runs each fuzz test for 180 seconds
    vars:
      FUZZTIME: '{{.FUZZTIME| default "180"}}'
    cmd: ./scripts/build_fuzz.sh {{.FUZZTIME}}

  test-fuzz-merkledb:
    desc: Runs each merkledb fuzz test for 15 minutes
    vars:
      FUZZTIME: '{{.FUZZTIME| default "900"}}'
    cmd: ./scripts/build_fuzz.sh {{.FUZZTIME}} ./x/merkledb

  test-load:
    desc: Runs load tests
    cmds:
      - task: generate-load-contract-bindings
      - task: build
      - cmd: go run ./tests/load/c/main --avalanchego-path=./build/avalanchego {{.CLI_ARGS}}

  test-load-kube-kind:
    desc: Runs load tests against a kind cluster
    cmds:
      - task: generate-load-contract-bindings
      - cmd: bash -x ./scripts/tests.load.kube.kind.sh {{.CLI_ARGS}}

  test-load-kube-remote:
    desc: Runs load tests against a remote kubernetes cluster
    vars:
      KUBE_IMAGE: '{{.KUBE_IMAGE | default "avaplatform/avalanchego:latest"}}'
    cmds:
      - task: generate-load-contract-bindings
      - cmd: go run ./tests/load/c/main --runtime=kube --kube-image={{.KUBE_IMAGE}} {{.CLI_ARGS}}

  test-load-exclusive:
    desc: Runs load tests against kube with exclusive scheduling
    cmds:
      - cmd: go run ./tests/load/c/main --runtime=kube --kube-use-exclusive-scheduling {{.CLI_ARGS}}

  test-unit:
    desc: Runs unit tests
    # Invoking with bash ensures compatibility with CI execution on Windows
    cmd: bash ./scripts/build_test.sh

  test-upgrade:
    desc: Runs upgrade tests
    cmds:
      - task: build
      - cmd: bash -x ./scripts/tests.upgrade.sh {{.CLI_ARGS}}
